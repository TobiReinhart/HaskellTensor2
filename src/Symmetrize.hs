--this module allows us to symmetrize the list of ansatz index combinations generated by Ansatz

module Symmetrize (


)
where

    import Data.List
    import qualified Data.Sequence as S
    import qualified Data.Map.Strict as M
    import Data.Maybe

    --the first step is defining functions for the symmetrization of Sequences

    --first we need the 2 basic swaps

    swapPos :: (Int,Int) -> S.Seq a -> S.Seq a
    swapPos (i,j) seq = S.update j a $ S.update i b seq
            where 
                a = fromJust $ S.lookup i seq
                b = fromJust $ S.lookup j seq

    swapLabel :: Eq a => (a,a) -> S.Seq a -> S.Seq a
    swapLabel (x,y) seq = fmap f seq 
            where
                f = swapLabelF (x,y) 

    swapLabelF :: Eq a => (a,a) -> a -> a 
    swapLabelF (x,y) z
            | x == z = y
            | y == z = x
            | otherwise = z 

    swapBlockPos :: ([Int],[Int]) -> S.Seq a -> S.Seq a
    swapBlockPos (i,j) s 
            | length i /= length j = error "only blocks with the same lenght can be symmetrized"
            | otherwise = foldr swapPos s pairList
                where
                    pairList = zip i j

    swapBlockLabel :: Eq a => ([a],[a]) -> S.Seq a -> S.Seq a
    swapBlockLabel (i,j) s 
            | length i /= length j = error "only blocks with the same lenght can be symmetrized"
            | otherwise = foldr swapLabel s pairList
                where
                    pairList = zip i j

    --now the cyclic symmetry
 
    update1CyclePos :: ([Int],[Int]) -> (S.Seq a) -> (S.Seq a)
    update1CyclePos (i,j) s = foldr updateS s updateList 
            where 
                updateList = zip i $ map (fromJust.((S.!?) s)) j
                updateS = \x -> S.update (fst x) (snd x) 

    cyclicSwapPos :: [Int] -> (S.Seq a) -> [(S.Seq a)]
    cyclicSwapPos l s = s : ( map (\x -> update1CyclePos x s) cList )
            where 
                perm = tail $ permutations l 
                cList = zip (repeat l) perm 

    
    update1CycleLabel :: (Eq a, Ord a) => ([a],[a]) -> (S.Seq a) -> (S.Seq a)
    update1CycleLabel (i,j) s = fmap f s 
            where 
                f = update1CycleLabelF (i,j)

    
    update1CycleLabelF :: (Eq a, Ord a) => ([a],[a]) -> a -> a 
    update1CycleLabelF (x,y) z
            | isJust mVal = fromJust mVal
            | otherwise = z 
                where 
                    zipList = zip x y 
                    zipMap = M.fromList zipList 
                    mVal = M.lookup z zipMap
    

    cyclicSwapLabel :: (Eq a, Ord a) => [a] -> (S.Seq a) -> [(S.Seq a)]
    cyclicSwapLabel l s = s : ( map (\x -> update1CycleLabel x s) cList )
            where 
                perm = tail $ permutations l 
                cList = zip (repeat l) perm 

    --now for block symmetries

    cyclicSwapBlockPos :: [[Int]] -> S.Seq a -> [S.Seq a]
    cyclicSwapBlockPos l s = s : ( map (\x -> update1CyclePos x s) cList )
            where
                perm = map concat $ tail $ permutations l
                cList = zip (repeat $ concat l) perm

    cyclicSwapBlockLabel :: (Eq a, Ord a) => [[a]] -> S.Seq a -> [S.Seq a]
    cyclicSwapBlockLabel l s = s : ( map (\x -> update1CycleLabel x s) cList )
            where
                perm = map concat $ tail $ permutations l
                cList = zip (repeat $ concat l) perm
    
    --so far the symmetrizer functions work
            
