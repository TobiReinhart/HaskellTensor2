
==================== FINAL INTERFACE ====================
2019-01-23 19:37:40.441555 UTC

interface main:Ansatz2 [hpc] 8043
  interface hash: 94470db538ad284a4b39142af9431c24
  ABI hash: f88571b424737d7ee4490174ceb01bb9
  export-list hash: 1a77670bc5de6f048cf25ffc1e61529c
  orphan hash: 5a8d917f6cd3b0c8f6db2c8b92c9f8c0
  flag hash: badd6e954112606c59e049e70d21435f
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ansatz2.getAllInds
  Ansatz2.getAllIndsEpsilon
  Ansatz2.getAllIndsEta
  Ansatz2.mkForest
  Ansatz2.mkTree
  Ansatz2.Edge
  Ansatz2.Root
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0* deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Tree
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.IntMap.Strict 79a3c61ca2c76eb71c4304029717e288
import  -/  containers-0.5.11.0:Data.Tree 334e5590b70599cff00c9af57a2f6140
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
3e074263e4f1afda2f3836c417e9ec0e
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  Ansatz2.$s$fEq(,)_$s$fEq(,)_$c/= -}
46d43b8369148b3db6065069eeecda39
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int))
                   (y :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
9a4cb54e0399d1ba309219220829cc54
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Ansatz2.$trModule3
                   Ansatz2.$trModule1) -}
cecce9de12e7776a335032801bec2926
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz2.$trModule2) -}
5439d208d25341476a6adb77378a6404
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ansatz2"#) -}
2933a5851b7f10fadd66a6401dc7a80c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz2.$trModule4) -}
b05925b5de12165e8c9cad416a4947e8
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
6245defdececd3fdc0fc0b7c65c42cda
  $wmkTree ::
    Ansatz2.Root
    -> [Ansatz2.Edge]
    -> (# GHC.Types.Int, Data.Tree.Forest GHC.Types.Int #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,U>,
     Inline: [0] -}
6d6ed91496f8161f2d8083244e692f46
  type Edge = (GHC.Types.Int, GHC.Types.Int)
46e1688a8870f4f85a701954e8302778
  type Root = GHC.Types.Int
d677f688c34cbbc4dc8f47502ebf16e2
  getAllInds :: [Ansatz2.Edge] -> [Ansatz2.Root] -> [[GHC.Types.Int]]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (edges :: [Ansatz2.Edge]) (roots :: [Ansatz2.Root]) ->
                 {__scc {main:Ansatz2.getAllInds} True True} Ansatz2.getTopSorts
                                                               (Ansatz2.mkForest edges roots)) -}
78deb41872ff7ff9310c863fd88b3cf2
  getAllIndsEpsilon :: [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, Strictness: <S,U> -}
efede7d9dd5e3a02a24a43ddf178f5dc
  getAllIndsEta :: [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 {__scc {main:Ansatz2.getAllIndsEta} True True} case ds of wild {
                                                                  [] -> Ansatz2.getAllIndsEta1
                                                                  : a ds1
                                                                  -> let {
                                                                       fail :: GHC.Prim.Void#
                                                                               -> [[GHC.Types.Int]]
                                                                         <join 1> {- Arity: 1,
                                                                                     Strictness: <L,A> -}
                                                                       = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                                                                         let {
                                                                           l :: [([GHC.Types.Int],
                                                                                  [GHC.Types.Int])]
                                                                           = {__scc {main:Ansatz2.getAllIndsEta.l} True True} GHC.Base.map
                                                                                                                                @ GHC.Types.Int
                                                                                                                                @ ([GHC.Types.Int],
                                                                                                                                   [GHC.Types.Int])
                                                                                                                                (\ (y :: GHC.Types.Int) ->
                                                                                                                                 {__scc {main:Ansatz2.getAllIndsEta.l.\} True False} (GHC.Types.:
                                                                                                                                                                                        @ GHC.Types.Int
                                                                                                                                                                                        a
                                                                                                                                                                                        (GHC.Types.:
                                                                                                                                                                                           @ GHC.Types.Int
                                                                                                                                                                                           y
                                                                                                                                                                                           (GHC.Types.[]
                                                                                                                                                                                              @ GHC.Types.Int)),
                                                                                                                                                                                      {__scc {main:Ansatz2.getAllIndsEta.l.\} False True} Data.OldList.deleteBy
                                                                                                                                                                                                                                            @ GHC.Types.Int
                                                                                                                                                                                                                                            GHC.Classes.eqInt
                                                                                                                                                                                                                                            y
                                                                                                                                                                                                                                            ds1))
                                                                                                                                ds1
                                                                         } in
                                                                         {__scc {main:Ansatz2.getAllIndsEta.res} True True} Ansatz2.getAllIndsEta_go
                                                                                                                              l
                                                                     } in
                                                                     case ds1 of wild1 {
                                                                       [] -> fail GHC.Prim.void#
                                                                       : b ds2
                                                                       -> case ds2 of wild2 {
                                                                            []
                                                                            -> GHC.Types.:
                                                                                 @ [GHC.Types.Int]
                                                                                 (GHC.Types.:
                                                                                    @ GHC.Types.Int
                                                                                    a
                                                                                    (GHC.Types.:
                                                                                       @ GHC.Types.Int
                                                                                       b
                                                                                       (GHC.Types.[]
                                                                                          @ GHC.Types.Int)))
                                                                                 (GHC.Types.[]
                                                                                    @ [GHC.Types.Int])
                                                                            : ipv ipv1
                                                                            -> fail
                                                                                 GHC.Prim.void# } } }) -}
6614f7e864c5bbb558f9cfd9c8be54c4
  getAllIndsEta1 :: [[GHC.Types.Int]]
  {- Strictness: x -}
a06201d2549e8cad7670e01dad1020b9
  getAllIndsEta_go ::
    [([GHC.Types.Int], [GHC.Types.Int])] -> [[GHC.Types.Int]]
  {- Arity: 1, Strictness: <S,1*U> -}
515befa26c4de5edec36f7da1fffa78f
  getTopSorts :: Data.Tree.Forest GHC.Types.Int -> [[GHC.Types.Int]]
  {- Arity: 1, Strictness: <S,U> -}
ab74eda91c4f9a8ee9a16c758d7a9b15
  mkForest ::
    [Ansatz2.Edge] -> [Ansatz2.Root] -> Data.Tree.Forest GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (edges :: [Ansatz2.Edge])
                   (leafs :: [Ansatz2.Root]) ->
                 {__scc {main:Ansatz2.mkForest} True True} let {
                                                             z :: [Data.Tree.Tree Ansatz2.Root]
                                                             = GHC.Base.map
                                                                 @ GHC.Types.Int
                                                                 @ (Data.Tree.Tree Ansatz2.Root)
                                                                 (\ (x :: Ansatz2.Root) ->
                                                                  {__scc {main:Ansatz2.mkForest.\} True True} Ansatz2.mkTree
                                                                                                                x
                                                                                                                edges)
                                                                 ({__scc {main:Ansatz2.getFirstNodes} True True} let {
                                                                                                                   sndNodes :: [GHC.Types.Int]
                                                                                                                   = {__scc {main:Ansatz2.getFirstNodes.sndNodes} True True} GHC.Base.map
                                                                                                                                                                               @ (GHC.Types.Int,
                                                                                                                                                                                  GHC.Types.Int)
                                                                                                                                                                               @ GHC.Types.Int
                                                                                                                                                                               (Data.Tuple.snd
                                                                                                                                                                                  @ GHC.Types.Int
                                                                                                                                                                                  @ GHC.Types.Int)
                                                                                                                                                                               edges
                                                                                                                 } in
                                                                                                                 letrec {
                                                                                                                   go :: [(GHC.Types.Int,
                                                                                                                           GHC.Types.Int)]
                                                                                                                         -> [GHC.Types.Int]
                                                                                                                     {- Arity: 1,
                                                                                                                        Strictness: <S,1*U> -}
                                                                                                                   = \ (ds :: [(GHC.Types.Int,
                                                                                                                                GHC.Types.Int)]) ->
                                                                                                                     case ds of wild {
                                                                                                                       []
                                                                                                                       -> GHC.Types.[]
                                                                                                                            @ GHC.Types.Int
                                                                                                                       : y ys
                                                                                                                       -> case y of wild1 { (,) a b ->
                                                                                                                          case {__scc {main:Ansatz2.getFirstNodes.\} True True} GHC.List.elem
                                                                                                                                                                                  @ GHC.Types.Int
                                                                                                                                                                                  GHC.Classes.$fEqInt
                                                                                                                                                                                  a
                                                                                                                                                                                  sndNodes of wild2 {
                                                                                                                            GHC.Types.False
                                                                                                                            -> GHC.Types.:
                                                                                                                                 @ GHC.Types.Int
                                                                                                                                 a
                                                                                                                                 (go
                                                                                                                                    ys)
                                                                                                                            GHC.Types.True
                                                                                                                            -> go
                                                                                                                                 ys } } }
                                                                                                                 } in
                                                                                                                 Data.OldList.nubBy
                                                                                                                   @ GHC.Types.Int
                                                                                                                   GHC.Classes.eqInt
                                                                                                                   (go
                                                                                                                      edges))
                                                           } in
                                                           letrec {
                                                             go :: [GHC.Types.Int]
                                                                   -> [Data.Tree.Tree Ansatz2.Root]
                                                               {- Arity: 1, Strictness: <S,1*U> -}
                                                             = \ (ds :: [GHC.Types.Int]) ->
                                                               case ds of wild {
                                                                 [] -> z
                                                                 : y ys
                                                                 -> GHC.Types.:
                                                                      @ (Data.Tree.Tree
                                                                           Ansatz2.Root)
                                                                      ({__scc {main:Ansatz2.mkForest.\} True False} Data.Tree.Node
                                                                                                                      @ Ansatz2.Root
                                                                                                                      y
                                                                                                                      (GHC.Types.[]
                                                                                                                         @ (Data.Tree.Tree
                                                                                                                              Ansatz2.Root)))
                                                                      (go ys) }
                                                           } in
                                                           go leafs) -}
fd58686b54abeb4aaabf761eba189d56
  mkTree ::
    Ansatz2.Root -> [Ansatz2.Edge] -> Data.Tree.Tree GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Ansatz2.Root) (w1 :: [Ansatz2.Edge]) ->
                 case Ansatz2.$wmkTree w w1 of ww { (#,#) ww1 ww2 ->
                 Data.Tree.Node @ GHC.Types.Int ww1 ww2 }) -}
"SPEC/Ansatz2 $fEq(,) @ Int @ Int" [orphan] forall (v1 :: GHC.Classes.Eq
                                                            GHC.Types.Int)
                                                   (v :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int v v1
  = Ansatz2.$s$fEq(,)
"SPEC/Ansatz2 $fEq(,)_$c/= @ Int @ Int" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                    GHC.Types.Int)
                                                        ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Ansatz2.$s$fEq(,)_$s$fEq(,)_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

