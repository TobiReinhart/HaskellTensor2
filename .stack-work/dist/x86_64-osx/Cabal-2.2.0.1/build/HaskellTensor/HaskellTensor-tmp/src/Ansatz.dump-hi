
==================== FINAL INTERFACE ====================
2019-01-22 14:45:58.047643 UTC

interface main:Ansatz [hpc] 8043
  interface hash: a2cac0f499226ddf013681c43aa98f0d
  ABI hash: f73908cbebb99b64870766cefd70bd60
  export-list hash: d003aa5bf1bb4010f41a5bd7e042ed4f
  orphan hash: 0dde965f356f3e405547b440e184ccad
  flag hash: badd6e954112606c59e049e70d21435f
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ansatz.getAllInds
  Ansatz.getAllIndsInverse
  Ansatz.getAllIndsLabel
  Ansatz.getAllIndsLabelInverse
  Ansatz.indexPermSeq
  Ansatz.mkIndMap
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0* deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.IntMap.Internal ef73a09d9589b16c95e337bc0715aa57
import  -/  containers-0.5.11.0:Data.IntMap.Strict 79a3c61ca2c76eb71c4304029717e288
import  -/  containers-0.5.11.0:Data.Sequence 21c58838329d44e2dc13db7c04e3a8d8
import  -/  containers-0.5.11.0:Data.Sequence.Internal a2eae372f67713826bf16d410fc6cd8f
import  -/  containers-0.5.11.0:Data.Sequence.Internal.Sorting 481f0d31b76dfcad90c740727653678b
import  -/  containers-0.5.11.0:Data.Set 7d3c64a641be4cacbcd8119445bab919
import  -/  containers-0.5.11.0:Data.Set.Internal 93fa3ef95853aa2a7aadf32d693bd451
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
9052089a7aebda6d19da6177daa962a1
  $fShowTree :: GHC.Show.Show Ansatz.Tree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Ansatz.Tree
                  Ansatz.$fShowTree_$cshowsPrec
                  Ansatz.$fShowTree_$cshow
                  Ansatz.$fShowTree_$cshowList -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree1 :: Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Ansatz.Tree) -> Ansatz.$w$cshowsPrec 0# w) -}
a29a7c53ab4cca2d2f413a3799bfe0f6
  $fShowTree2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshow :: Ansatz.Tree -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Ansatz.Tree) ->
                 Ansatz.$fShowTree_$cshowsPrec
                   Ansatz.$fShowTree2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshowList :: [Ansatz.Tree] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Ansatz.Tree]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Ansatz.Tree Ansatz.$fShowTree1 ls s) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshowsPrec ::
    GHC.Types.Int -> Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Ansatz.Tree) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Ansatz.$w$cshowsPrec ww1 w1 }) -}
93adf8a89aa52843bec5314631f1f3a0
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  Ansatz.$s$fEq(,)_$s$fEq(,)_$c/= -}
c9a387433575b340b68c3abc8df6b8e8
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int))
                   (y :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
7ccf27f361b94df174aa1f5fe920a8c1
  $s$fFoldableSet_$celem_go3 ::
    GHC.Types.Int
    -> Data.Set.Internal.Set GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Set.Internal.Set GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Ansatz.$wgo3 ww1 w1 }) -}
b548dc22626da76d18036d4541cede6b
  $sfromList ::
    [GHC.Types.Int] -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ GHC.Types.Int
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x of dt { GHC.Types.I# ipv ->
                           Data.Set.Internal.Bin
                             @ GHC.Types.Int
                             1#
                             dt
                             (Data.Set.Internal.Tip @ GHC.Types.Int)
                             (Data.Set.Internal.Tip @ GHC.Types.Int) }
                        : ipv ipv1
                        -> case x of wild2 { GHC.Types.I# x1 ->
                           case ipv of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x1 y of lwild {
                             DEFAULT
                             -> Ansatz.$wgo1
                                  1#
                                  (Data.Set.Internal.Bin
                                     @ GHC.Types.Int
                                     1#
                                     wild2
                                     (Data.Set.Internal.Tip @ GHC.Types.Int)
                                     (Data.Set.Internal.Tip @ GHC.Types.Int))
                                  wild1
                             1#
                             -> Ansatz.$sfromList_go4
                                  (Data.Set.Internal.Bin
                                     @ GHC.Types.Int
                                     1#
                                     wild2
                                     (Data.Set.Internal.Tip @ GHC.Types.Int)
                                     (Data.Set.Internal.Tip @ GHC.Types.Int))
                                  wild1 } } } } }) -}
97920bd554f1642f232ce6472345754d
  $sfromList_go4 ::
    Data.Set.Internal.Set GHC.Types.Int
    -> [GHC.Types.Int] -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c028212e6a2ffb80e86087c947186bf6
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2033514455733432812##
                   18002265259541182205##
                   Ansatz.$trModule
                   Ansatz.$tc'Leaf2
                   0#
                   Ansatz.$tc'Leaf1) -}
6bcc49d7dc3cb017711ed47330f3ce74
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2f6bf5ac5a76e13f7b7b413319d278e5
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tc'Leaf3) -}
ecf6b35a2a13b56d82626fc04822b076
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
1d3e7b8c8e5f4570ea6f96cffad30c5a
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8484511398144826853##
                   8047462201378559702##
                   Ansatz.$trModule
                   Ansatz.$tc'Node2
                   0#
                   Ansatz.$tc'Node1) -}
45b9bfa2787704e91e73bb3e3d5e4f89
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6d7b3a56f93ef1eec3f27debfb6cd539
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tc'Node3) -}
3b54b7f7dd91aff44742e7b3be2d3fb7
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
5d21e82209cf6e1a02c3a4b701b1a61d
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15185055251514789673##
                   10103094257428114360##
                   Ansatz.$trModule
                   Ansatz.$tcTree1
                   0#
                   GHC.Types.krep$*) -}
62049c79d96dd197f51dc9e2aaf04956
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tcTree2) -}
670096d934b3bc4b8ed7af231a93f0fb
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
b91f634ffb12f6062519c5bfa9ef14eb
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Ansatz.$trModule3
                   Ansatz.$trModule1) -}
efc641f831a00a4f54bf971870c48acb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$trModule2) -}
c3228c1332902a45eac2af8a83dab40c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ansatz"#) -}
f3763ba4635ccf1cc7ccc046ca5af206
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$trModule4) -}
405fc588e2932382c2db604859696980
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
9052089a7aebda6d19da6177daa962a1
  $w$cshowsPrec :: GHC.Prim.Int# -> Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
5cf00763d47f238c49e29ceabddf5cbc
  $w$sgo3 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int
    -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
b916b0e1cc3fa7ea2828b1acaeddc965
  $wgo1 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int
    -> [GHC.Types.Int]
    -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
06408f3e54b6ee1c26a9d67c6b106c8b
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
547a4a3d91ef0366afafa8f0debc9aad
  $wlvl ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.GT 1# -> GHC.Classes.compareInt ww1 ww3 }
                   1# -> GHC.Types.LT }) -}
354d6fb1094c4d8e1958811937236204
  type Edge = (GHC.Types.Int, GHC.Types.Int)
a456c151c9e277d0f28775b01686b8a7
  type Forest = Data.Sequence.Internal.Seq Ansatz.Tree
edc911a4fd3a327199cdf82382a0ae98
  type Root = GHC.Types.Int
9052089a7aebda6d19da6177daa962a1
  data Tree
    = Leaf GHC.Types.Int
    | Node GHC.Types.Int (Data.Sequence.Internal.Seq Ansatz.Tree)
f97716c1ab6421429a03cd0ddc22a1c2
  getAllInds ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 {__scc {main:Ansatz.getAllInds} True True} let {
                                                              forest :: Data.Sequence.Internal.FingerTree
                                                                          (Data.Sequence.Internal.Elem
                                                                             Ansatz.Tree)
                                                              = {__scc {main:Ansatz.getAllInds.forest} True True} Ansatz.getAllInds2
                                                                                                                    edges
                                                                                                                    roots
                                                            } in
                                                            GHC.List.filter
                                                              @ (Data.Sequence.Internal.Seq
                                                                   GHC.Types.Int)
                                                              (\ (x :: Data.Sequence.Internal.Seq
                                                                         GHC.Types.Int) ->
                                                               {__scc {main:Ansatz.getAllInds.\} True True} Ansatz.getAllInds1
                                                                                                              x
                                                                                                              symList)
                                                                `cast`
                                                              (<Data.Sequence.Internal.Seq
                                                                  GHC.Types.Int>_R
                                                               ->_R Data.Semigroup.Internal.N:All[0])
                                                              ({__scc {main:Ansatz.getAllInds.topSorts} True True} Ansatz.getTopSortsSeq
                                                                                                                     forest
                                                                                                                       `cast`
                                                                                                                     (Sym (Data.Sequence.Internal.N:Seq[0]
                                                                                                                               <Ansatz.Tree>_R)))) -}
61c915fa03e183e90ca13cfd53c6eb08
  getAllInds1 ::
    Data.Sequence.Internal.Seq GHC.Types.Int
    -> [(GHC.Types.Int, GHC.Types.Int)] -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (seq :: Data.Sequence.Internal.Seq GHC.Types.Int)
                   (list :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 {__scc {main:Ansatz.filterSym} True True} Ansatz.getAllInds_go
                                                             ({__scc {main:Ansatz.filterSym.boolList} True True} GHC.Base.map
                                                                                                                   @ (GHC.Types.Int,
                                                                                                                      GHC.Types.Int)
                                                                                                                   @ GHC.Types.Bool
                                                                                                                   (\ (ds :: (GHC.Types.Int,
                                                                                                                              GHC.Types.Int)) ->
                                                                                                                    {__scc {main:Ansatz.filter1Sym} True True} case ds of wild { (,) i j ->
                                                                                                                                                               {__scc {main:Ansatz.filter1Sym.a} True False} case i of wild1 { GHC.Types.I# x ->
                                                                                                                                                                                                             case {__scc {main:Ansatz.filter1Sym.a} False True} Data.Sequence.Internal.$windex
                                                                                                                                                                                                                                                                  @ GHC.Types.Int
                                                                                                                                                                                                                                                                  seq
                                                                                                                                                                                                                                                                  (GHC.Prim.-#
                                                                                                                                                                                                                                                                     x
                                                                                                                                                                                                                                                                     1#) of wild2 { GHC.Types.I# x1 ->
                                                                                                                                                                                                             {__scc {main:Ansatz.filter1Sym.b} True False} case j of wild3 { GHC.Types.I# x2 ->
                                                                                                                                                                                                                                                           case {__scc {main:Ansatz.filter1Sym.b} False True} Data.Sequence.Internal.$windex
                                                                                                                                                                                                                                                                                                                @ GHC.Types.Int
                                                                                                                                                                                                                                                                                                                seq
                                                                                                                                                                                                                                                                                                                (GHC.Prim.-#
                                                                                                                                                                                                                                                                                                                   x2
                                                                                                                                                                                                                                                                                                                   1#) of wild4 { GHC.Types.I# y ->
                                                                                                                                                                                                                                                           GHC.Prim.tagToEnum#
                                                                                                                                                                                                                                                             @ GHC.Types.Bool
                                                                                                                                                                                                                                                             (GHC.Prim.<#
                                                                                                                                                                                                                                                                x1
                                                                                                                                                                                                                                                                y) } } } } })
                                                                                                                   list)) -}
9324061a6ae53596cd04c2e6ecd92290
  getAllInds2 ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> Data.Sequence.Internal.FingerTree
         (Data.Sequence.Internal.Elem Ansatz.Tree)
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (edges :: [Ansatz.Edge]) (leafs :: [Ansatz.Root]) ->
                 {__scc {main:Ansatz.mkForest} True True} let {
                                                            z :: [Ansatz.Tree]
                                                            = GHC.Base.map
                                                                @ GHC.Types.Int
                                                                @ Ansatz.Tree
                                                                (\ (x :: Ansatz.Root) ->
                                                                 {__scc {main:Ansatz.mkForest.\} True True} Ansatz.mkTree
                                                                                                              x
                                                                                                              edges)
                                                                ({__scc {main:Ansatz.getFirstNodes} True True} let {
                                                                                                                 sndNodes :: Data.Set.Internal.Set
                                                                                                                               GHC.Types.Int
                                                                                                                 = {__scc {main:Ansatz.getFirstNodes.sndNodes} True True} Ansatz.$sfromList
                                                                                                                                                                            (GHC.Base.map
                                                                                                                                                                               @ (GHC.Types.Int,
                                                                                                                                                                                  GHC.Types.Int)
                                                                                                                                                                               @ GHC.Types.Int
                                                                                                                                                                               Ansatz.getAllInds3
                                                                                                                                                                               edges)
                                                                                                               } in
                                                                                                               letrec {
                                                                                                                 go :: [(GHC.Types.Int,
                                                                                                                         GHC.Types.Int)]
                                                                                                                       -> [GHC.Types.Int]
                                                                                                                   {- Arity: 1,
                                                                                                                      Strictness: <S,1*U> -}
                                                                                                                 = \ (ds :: [(GHC.Types.Int,
                                                                                                                              GHC.Types.Int)]) ->
                                                                                                                   case ds of wild {
                                                                                                                     []
                                                                                                                     -> GHC.Types.[]
                                                                                                                          @ GHC.Types.Int
                                                                                                                     : y ys
                                                                                                                     -> case y of wild1 { (,) a b ->
                                                                                                                        case {__scc {main:Ansatz.getFirstNodes.\} True True} Ansatz.$s$fFoldableSet_$celem_go3
                                                                                                                                                                               a
                                                                                                                                                                               sndNodes of wild2 {
                                                                                                                          GHC.Types.False
                                                                                                                          -> GHC.Types.:
                                                                                                                               @ GHC.Types.Int
                                                                                                                               ({__scc {main:Ansatz.getFirstNodes.\} True False} a)
                                                                                                                               (go
                                                                                                                                  ys)
                                                                                                                          GHC.Types.True
                                                                                                                          -> go
                                                                                                                               ys } } }
                                                                                                               } in
                                                                                                               Data.Set.Internal.$fDataSet_go
                                                                                                                 @ GHC.Types.Int
                                                                                                                 (GHC.Types.[]
                                                                                                                    @ GHC.Types.Int)
                                                                                                                 (Ansatz.$sfromList
                                                                                                                    (go
                                                                                                                       edges)))
                                                          } in
                                                          letrec {
                                                            go :: [GHC.Types.Int] -> [Ansatz.Tree]
                                                              {- Arity: 1, Strictness: <S,1*U> -}
                                                            = \ (ds :: [GHC.Types.Int]) ->
                                                              case ds of wild {
                                                                [] -> z
                                                                : y ys
                                                                -> GHC.Types.:
                                                                     @ Ansatz.Tree
                                                                     (Ansatz.Leaf y)
                                                                     (go ys) }
                                                          } in
                                                          Data.Sequence.Internal.$fIsListSeq_mkTree
                                                            @ Ansatz.Tree
                                                            @ Ansatz.Tree
                                                            (go leafs)
                                                              `cast`
                                                            ([Sym (Data.Sequence.Internal.N:Elem[0]
                                                                       <Ansatz.Tree>_R)])_R) -}
05ab5da3d0b0e853d669fcf4e87fa805
  getAllInds3 :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case ds of wild { (,) a b ->
                 {__scc {main:Ansatz.getFirstNodes.sndNodes.\} True False} b }) -}
e2fb268c4c0d02483b6b9d7ff2f96ac1
  getAllIndsInverse ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 {__scc {main:Ansatz.getAllIndsInverse} True True} let {
                                                                     forest :: Data.Sequence.Internal.FingerTree
                                                                                 (Data.Sequence.Internal.Elem
                                                                                    Ansatz.Tree)
                                                                     = {__scc {main:Ansatz.getAllIndsInverse.forest} True True} Ansatz.getAllInds2
                                                                                                                                  edges
                                                                                                                                  roots
                                                                   } in
                                                                   let {
                                                                     topSorts :: [Data.Sequence.Internal.Seq
                                                                                    GHC.Types.Int]
                                                                     = {__scc {main:Ansatz.getAllIndsInverse.topSorts} True True} Ansatz.getTopSortsSeq
                                                                                                                                    forest
                                                                                                                                      `cast`
                                                                                                                                    (Sym (Data.Sequence.Internal.N:Seq[0]
                                                                                                                                              <Ansatz.Tree>_R))
                                                                   } in
                                                                   let {
                                                                     ord :: Data.Sequence.Internal.FingerTree
                                                                              (Data.Sequence.Internal.Elem
                                                                                 GHC.Types.Int)
                                                                     = case ({__scc {main:Ansatz.getAllIndsInverse.s} True True} GHC.List.$w!!
                                                                                                                                   @ (Data.Sequence.Internal.Seq
                                                                                                                                        GHC.Types.Int)
                                                                                                                                   topSorts
                                                                                                                                   0#)
                                                                              `cast`
                                                                            (Data.Sequence.Internal.N:Seq[0]
                                                                                 <GHC.Types.Int>_R) of wild {
                                                                         Data.Sequence.Internal.EmptyT
                                                                         -> {__scc {main:Ansatz.invertPermSeq} False True} {__scc {main:Ansatz.invertPermSeq.ord} True False} Ansatz.getAllIndsInverse3
                                                                         Data.Sequence.Internal.Single x
                                                                         -> {__scc {main:Ansatz.invertPermSeq} False True} {__scc {main:Ansatz.invertPermSeq.ord} True False} Ansatz.getAllIndsInverse2
                                                                         Data.Sequence.Internal.Deep dt ds1 ds2 ds3
                                                                         -> {__scc {main:Ansatz.invertPermSeq} False True} {__scc {main:Ansatz.invertPermSeq.ord} True True} Data.Sequence.Internal.$fIsListSeq_mkTree
                                                                                                                                                                               @ GHC.Types.Int
                                                                                                                                                                               @ GHC.Types.Int
                                                                                                                                                                               (GHC.Enum.eftInt
                                                                                                                                                                                  1#
                                                                                                                                                                                  dt)
                                                                                                                                                                                 `cast`
                                                                                                                                                                               ([Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                                                                          <GHC.Types.Int>_R)])_R }
                                                                   } in
                                                                   letrec {
                                                                     go :: [Data.Sequence.Internal.Seq
                                                                              GHC.Types.Int]
                                                                           -> [Data.Sequence.Internal.Seq
                                                                                 GHC.Types.Int]
                                                                       {- Arity: 1,
                                                                          Strictness: <S,1*U> -}
                                                                     = \ (ds :: [Data.Sequence.Internal.Seq
                                                                                   GHC.Types.Int]) ->
                                                                       case ds of wild {
                                                                         []
                                                                         -> GHC.Types.[]
                                                                              @ (Data.Sequence.Internal.Seq
                                                                                   GHC.Types.Int)
                                                                         : y ys
                                                                         -> case ({__scc {main:Ansatz.getAllIndsInverse.\} True True} Ansatz.getAllInds1
                                                                                                                                        y
                                                                                                                                        symList)
                                                                                   `cast`
                                                                                 (Data.Semigroup.Internal.N:All[0]) of wild1 {
                                                                              GHC.Types.False
                                                                              -> go ys
                                                                              GHC.Types.True
                                                                              -> GHC.Types.:
                                                                                   @ (Data.Sequence.Internal.Seq
                                                                                        GHC.Types.Int)
                                                                                   ({__scc {main:Ansatz.invertPermSeq} True True} let {
                                                                                                                                    zipSeq :: Data.Sequence.Internal.Seq
                                                                                                                                                (GHC.Types.Int,
                                                                                                                                                 GHC.Types.Int)
                                                                                                                                    = {__scc {main:Ansatz.invertPermSeq.zipSeq} True True} Data.Sequence.Internal.zipWith
                                                                                                                                                                                             @ GHC.Types.Int
                                                                                                                                                                                             @ GHC.Types.Int
                                                                                                                                                                                             @ (GHC.Types.Int,
                                                                                                                                                                                                GHC.Types.Int)
                                                                                                                                                                                             (GHC.Tuple.(,)
                                                                                                                                                                                                @ GHC.Types.Int
                                                                                                                                                                                                @ GHC.Types.Int)
                                                                                                                                                                                             y
                                                                                                                                                                                             ord
                                                                                                                                                                                               `cast`
                                                                                                                                                                                             (Sym (Data.Sequence.Internal.N:Seq[0]
                                                                                                                                                                                                       <GHC.Types.Int>_R))
                                                                                                                                  } in
                                                                                                                                  (Data.Sequence.Internal.$fFunctorSeq_$cfmap
                                                                                                                                     @ (Data.Sequence.Internal.Elem
                                                                                                                                          (GHC.Types.Int,
                                                                                                                                           GHC.Types.Int))
                                                                                                                                     @ (Data.Sequence.Internal.Elem
                                                                                                                                          GHC.Types.Int)
                                                                                                                                     (Data.Tuple.snd
                                                                                                                                        @ GHC.Types.Int
                                                                                                                                        @ GHC.Types.Int)
                                                                                                                                       `cast`
                                                                                                                                     (Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                               <(GHC.Types.Int,
                                                                                                                                                 GHC.Types.Int)>_R)
                                                                                                                                      ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                                    <GHC.Types.Int>_R))
                                                                                                                                     ({__scc {main:Ansatz.invertPermSeq.zipSeqSort} True True} Data.Sequence.Internal.Sorting.sortBy
                                                                                                                                                                                                 @ (GHC.Types.Int,
                                                                                                                                                                                                    GHC.Types.Int)
                                                                                                                                                                                                 Ansatz.getAllIndsInverse1
                                                                                                                                                                                                 zipSeq)
                                                                                                                                       `cast`
                                                                                                                                     (Data.Sequence.Internal.N:Seq[0]
                                                                                                                                          <(GHC.Types.Int,
                                                                                                                                            GHC.Types.Int)>_R))
                                                                                                                                    `cast`
                                                                                                                                  (Sym (Data.Sequence.Internal.N:Seq[0]
                                                                                                                                            <GHC.Types.Int>_R)))
                                                                                   (go ys) } }
                                                                   } in
                                                                   go topSorts) -}
7ea26508759726f0a45b0bbd45378e26
  getAllIndsInverse1 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { (,) ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Ansatz.$wlvl ww4 ww2 ww9 ww7 } } } }) -}
fd77e52ba5277698b1f13582c5fd5bf0
  getAllIndsInverse2 ::
    Data.Sequence.Internal.FingerTree
      (Data.Sequence.Internal.Elem GHC.Types.Int)
  {- Unfolding: ({__scc {main:Ansatz.getAllIndsInverse} False True} {__scc {main:Ansatz.invertPermSeq} False True} {__scc {main:Ansatz.invertPermSeq.ord} False True} Data.Sequence.Internal.$fIsListSeq_mkTree
                                                                                                                                                                        @ GHC.Types.Int
                                                                                                                                                                        @ GHC.Types.Int
                                                                                                                                                                        (GHC.Enum.eftInt
                                                                                                                                                                           1#
                                                                                                                                                                           1#)
                                                                                                                                                                          `cast`
                                                                                                                                                                        ([Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                                                                   <GHC.Types.Int>_R)])_R) -}
59ca77ff9fb7f2f1ccfbd28771f6f4bc
  getAllIndsInverse3 ::
    Data.Sequence.Internal.FingerTree
      (Data.Sequence.Internal.Elem GHC.Types.Int)
  {- Unfolding: ({__scc {main:Ansatz.getAllIndsInverse} False True} {__scc {main:Ansatz.invertPermSeq} False True} {__scc {main:Ansatz.invertPermSeq.ord} False True} Data.Sequence.Internal.$fIsListSeq_mkTree
                                                                                                                                                                        @ GHC.Types.Int
                                                                                                                                                                        @ GHC.Types.Int
                                                                                                                                                                        (GHC.Enum.eftInt
                                                                                                                                                                           1#
                                                                                                                                                                           0#)
                                                                                                                                                                          `cast`
                                                                                                                                                                        ([Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                                                                   <GHC.Types.Int>_R)])_R) -}
e03e808361151ff16b7e6f10a1ca594c
  getAllIndsLabel ::
    GHC.Base.String
    -> [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U><L,U><S,1*U><L,U>,
     Unfolding: (\ (inds :: GHC.Base.String)
                   (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 {__scc {main:Ansatz.getAllIndsLabel} True True} let {
                                                                   m :: Data.IntMap.Internal.IntMap
                                                                          GHC.Types.Char
                                                                   = {__scc {main:Ansatz.getAllIndsLabel.m} True True} Ansatz.mkIndMap
                                                                                                                         inds
                                                                 } in
                                                                 let {
                                                                   lvl6 :: GHC.Types.Int
                                                                           -> [GHC.Types.Char]
                                                                           -> [GHC.Types.Char]
                                                                     {- Arity: 2,
                                                                        Strictness: <L,1*U(U)><L,U> -}
                                                                   = \ (x :: GHC.Types.Int)
                                                                       (ys :: [GHC.Types.Char])[OneShot] ->
                                                                     GHC.Types.:
                                                                       @ GHC.Types.Char
                                                                       ({__scc {main:Ansatz.getAllIndsLabel.\} True True} Data.IntMap.Internal.!
                                                                                                                            @ GHC.Types.Char
                                                                                                                            m
                                                                                                                            x)
                                                                       ys
                                                                 } in
                                                                 Data.OldList.unlines
                                                                   (GHC.Base.map
                                                                      @ (Data.Sequence.Internal.Seq
                                                                           GHC.Types.Int)
                                                                      @ [GHC.Types.Char]
                                                                      (\ (x :: Data.Sequence.Internal.Seq
                                                                                 GHC.Types.Int) ->
                                                                       Data.Sequence.Internal.$fEq1Seq_$cfoldr
                                                                         @ (Data.Sequence.Internal.Elem
                                                                              GHC.Types.Int)
                                                                         @ [GHC.Types.Char]
                                                                         lvl6
                                                                           `cast`
                                                                         (Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                   <GHC.Types.Int>_R)
                                                                          ->_R <[GHC.Types.Char]
                                                                                -> [GHC.Types.Char]>_R)
                                                                         (GHC.Types.[]
                                                                            @ GHC.Types.Char)
                                                                         x `cast`
                                                                         (Data.Sequence.Internal.N:Seq[0]
                                                                              <GHC.Types.Int>_R))
                                                                      (Ansatz.getAllInds
                                                                         edges
                                                                         roots
                                                                         symList))) -}
f6f14507b3240cc34fb5ee7a60e1f686
  getAllIndsLabelInverse ::
    GHC.Base.String
    -> [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U><L,U><S,1*U><L,U>,
     Unfolding: (\ (inds :: GHC.Base.String)
                   (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 {__scc {main:Ansatz.getAllIndsLabelInverse} True True} let {
                                                                          m :: Data.IntMap.Internal.IntMap
                                                                                 GHC.Types.Char
                                                                          = {__scc {main:Ansatz.getAllIndsLabelInverse.m} True True} Ansatz.mkIndMap
                                                                                                                                       inds
                                                                        } in
                                                                        let {
                                                                          lvl6 :: GHC.Types.Int
                                                                                  -> [GHC.Types.Char]
                                                                                  -> [GHC.Types.Char]
                                                                            {- Arity: 2,
                                                                               Strictness: <L,1*U(U)><L,U> -}
                                                                          = \ (x :: GHC.Types.Int)
                                                                              (ys :: [GHC.Types.Char])[OneShot] ->
                                                                            GHC.Types.:
                                                                              @ GHC.Types.Char
                                                                              ({__scc {main:Ansatz.getAllIndsLabelInverse.\} True True} Data.IntMap.Internal.!
                                                                                                                                          @ GHC.Types.Char
                                                                                                                                          m
                                                                                                                                          x)
                                                                              ys
                                                                        } in
                                                                        Data.OldList.unlines
                                                                          (GHC.Base.map
                                                                             @ (Data.Sequence.Internal.Seq
                                                                                  GHC.Types.Int)
                                                                             @ [GHC.Types.Char]
                                                                             (\ (x :: Data.Sequence.Internal.Seq
                                                                                        GHC.Types.Int) ->
                                                                              Data.Sequence.Internal.$fEq1Seq_$cfoldr
                                                                                @ (Data.Sequence.Internal.Elem
                                                                                     GHC.Types.Int)
                                                                                @ [GHC.Types.Char]
                                                                                lvl6
                                                                                  `cast`
                                                                                (Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                          <GHC.Types.Int>_R)
                                                                                 ->_R <[GHC.Types.Char]
                                                                                       -> [GHC.Types.Char]>_R)
                                                                                (GHC.Types.[]
                                                                                   @ GHC.Types.Char)
                                                                                x `cast`
                                                                                (Data.Sequence.Internal.N:Seq[0]
                                                                                     <GHC.Types.Int>_R))
                                                                             (Ansatz.getAllIndsInverse
                                                                                edges
                                                                                roots
                                                                                symList))) -}
eb232eb43fe7c2dddfb40bc4e3ee669c
  getAllInds_go :: [GHC.Types.Bool] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
24672831fab0569817f3e0ae8aad08de
  getTopSortsSeq ::
    Ansatz.Forest -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 1, Strictness: <S,U> -}
0d4c1c99edf3fb66aaf13f548998bd50
  indexPermSeq ::
    Data.Sequence.Internal.Seq GHC.Types.Int
    -> Data.IntMap.Internal.IntMap GHC.Types.Char -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (a :: Data.Sequence.Internal.Seq GHC.Types.Int)
                   (b :: Data.IntMap.Internal.IntMap GHC.Types.Char) ->
                 {__scc {main:Ansatz.indexPermSeq} True True} let {
                                                                $j :: GHC.Base.String <join 0>
                                                                = GHC.CString.unpackAppendCString#
                                                                    Ansatz.indexPermSeq6
                                                                    (case {__scc {main:Ansatz.indexPermSeq.indList} True True} Data.Sequence.Internal.$fEq1Seq_$cfoldr
                                                                                                                                 @ (Data.Sequence.Internal.Elem
                                                                                                                                      Data.IntSet.Internal.Key)
                                                                                                                                 @ (GHC.Types.Int
                                                                                                                                    -> [GHC.Types.Char])
                                                                                                                                 (\ (x :: Data.IntSet.Internal.Key)
                                                                                                                                    (g :: GHC.Types.Int
                                                                                                                                          -> [GHC.Types.Char])[OneShot]
                                                                                                                                    (i :: GHC.Types.Int) ->
                                                                                                                                  case i of i1 { GHC.Types.I# ipv ->
                                                                                                                                  {__scc {main:Ansatz.indexPermSeq.indList.\} True False} GHC.Types.:
                                                                                                                                                                                            @ GHC.Types.Char
                                                                                                                                                                                            ({__scc {main:Ansatz.indexPermSeq.indList.\} False True} Data.IntMap.Internal.!
                                                                                                                                                                                                                                                       @ GHC.Types.Char
                                                                                                                                                                                                                                                       b
                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                            (g (GHC.Types.I#
                                                                                                                                                                                                  (GHC.Prim.+#
                                                                                                                                                                                                     ipv
                                                                                                                                                                                                     1#))) })
                                                                                                                                   `cast`
                                                                                                                                 (Sym (Data.Sequence.Internal.N:Elem[0]
                                                                                                                                           <Data.IntSet.Internal.Key>_R)
                                                                                                                                  ->_R <(GHC.Types.Int
                                                                                                                                         -> [GHC.Types.Char])
                                                                                                                                        -> GHC.Types.Int
                                                                                                                                        -> [GHC.Types.Char]>_R)
                                                                                                                                 Ansatz.indexPermSeq5
                                                                                                                                 a `cast`
                                                                                                                                 (Data.Sequence.Internal.N:Seq[0]
                                                                                                                                      <Data.IntSet.Internal.Key>_R)
                                                                                                                                 Ansatz.$fShowTree2 of wild {
                                                                       [] -> Ansatz.indexPermSeq3
                                                                       : x xs
                                                                       -> GHC.Base.++_$s++
                                                                            @ GHC.Types.Char
                                                                            Ansatz.indexPermSeq3
                                                                            x
                                                                            (Data.OldList.prependToAll
                                                                               @ GHC.Types.Char
                                                                               Ansatz.indexPermSeq2
                                                                               xs) })
                                                              } in
                                                              case a `cast`
                                                                   (Data.Sequence.Internal.N:Seq[0]
                                                                        <GHC.Types.Int>_R) of wild {
                                                                Data.Sequence.Internal.EmptyT
                                                                -> case Data.IntMap.Internal.$wgo
                                                                          @ GHC.Types.Char
                                                                          0#
                                                                          b of ww {
                                                                     DEFAULT -> Ansatz.indexPermSeq1
                                                                     0# -> $j }
                                                                Data.Sequence.Internal.Single x
                                                                -> case Data.IntMap.Internal.$wgo
                                                                          @ GHC.Types.Char
                                                                          0#
                                                                          b of ww {
                                                                     DEFAULT -> Ansatz.indexPermSeq1
                                                                     1# -> $j }
                                                                Data.Sequence.Internal.Deep dt ds1 ds2 ds3
                                                                -> case Data.IntMap.Internal.$wgo
                                                                          @ GHC.Types.Char
                                                                          0#
                                                                          b of ww { DEFAULT ->
                                                                   case GHC.Prim./=#
                                                                          dt
                                                                          ww of lwild {
                                                                     DEFAULT -> $j
                                                                     1#
                                                                     -> Ansatz.indexPermSeq1 } } }) -}
4ee44ebdd11428950322aae4aa2fd06d
  indexPermSeq1 :: GHC.Base.String
  {- Strictness: x -}
a7a60c65c99ca97691ec61b68321022b
  indexPermSeq2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ','#) -}
4775a6986c0c5bac189e51598cac2766
  indexPermSeq3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ansatz.indexPermSeq4) -}
cb3ce68c61114d9a68b98d88e71158df
  indexPermSeq4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("]"#) -}
6349c485f2d2e53f1dc97ac100a2d7aa
  indexPermSeq5 :: GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Int) -> GHC.Types.[] @ GHC.Types.Char) -}
38149d66145248010042bf070afed8c1
  indexPermSeq6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("["#) -}
7aab477f3e77b855d29a69a1ec3268ee
  mkIndMap ::
    GHC.Base.String -> Data.IntMap.Internal.IntMap GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (inds :: GHC.Base.String) ->
                 {__scc {main:Ansatz.mkIndMap} True True} Data.IntMap.Strict.fromList1
                                                            @ GHC.Types.Char
                                                            (Data.IntMap.Internal.Nil
                                                               @ GHC.Types.Char)
                                                            (Ansatz.mkIndMap_go 1# inds)) -}
d2d1522e242b589314a3d74b384f8de2
  mkIndMap_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Char)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
5a5868224ebdda63b3260af933f45150
  mkTree :: Ansatz.Root -> [Ansatz.Edge] -> Ansatz.Tree
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,U> -}
instance [safe] GHC.Show.Show [Ansatz.Tree] = Ansatz.$fShowTree
"SPEC/Ansatz $fEq(,) @ Int @ Int" [orphan] forall (v1 :: GHC.Classes.Eq
                                                           GHC.Types.Int)
                                                  (v :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int v v1
  = Ansatz.$s$fEq(,)
"SPEC/Ansatz $fEq(,)_$c/= @ Int @ Int" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                   GHC.Types.Int)
                                                       ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Ansatz.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Ansatz fromList @ Int" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                         GHC.Types.Int)
  Data.Set.Internal.fromList @ GHC.Types.Int $dOrd
  = Ansatz.$sfromList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

