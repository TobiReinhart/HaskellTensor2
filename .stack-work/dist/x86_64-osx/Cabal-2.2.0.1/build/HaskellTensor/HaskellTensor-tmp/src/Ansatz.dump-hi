
==================== FINAL INTERFACE ====================
2019-01-16 14:17:57.682647 UTC

interface main:Ansatz 8043
  interface hash: e38898e52ff960f6b5ab240adbf49540
  ABI hash: e80d045561c506e0590aa431c0cd1e76
  export-list hash: d003aa5bf1bb4010f41a5bd7e042ed4f
  orphan hash: 0dde965f356f3e405547b440e184ccad
  flag hash: 707c86cfbee6a9c65f08462953a21ad8
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ansatz.getAllInds
  Ansatz.getAllIndsInverse
  Ansatz.getAllIndsLabel
  Ansatz.getAllIndsLabelInverse
  Ansatz.indexPermSeq
  Ansatz.mkIndMap
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0* deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.IntMap.Internal ef73a09d9589b16c95e337bc0715aa57
import  -/  containers-0.5.11.0:Data.IntMap.Strict 79a3c61ca2c76eb71c4304029717e288
import  -/  containers-0.5.11.0:Data.Sequence 21c58838329d44e2dc13db7c04e3a8d8
import  -/  containers-0.5.11.0:Data.Sequence.Internal a2eae372f67713826bf16d410fc6cd8f
import  -/  containers-0.5.11.0:Data.Sequence.Internal.Sorting 481f0d31b76dfcad90c740727653678b
import  -/  containers-0.5.11.0:Data.Set 7d3c64a641be4cacbcd8119445bab919
import  -/  containers-0.5.11.0:Data.Set.Internal 93fa3ef95853aa2a7aadf32d693bd451
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
9052089a7aebda6d19da6177daa962a1
  $fShowTree :: GHC.Show.Show Ansatz.Tree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Ansatz.Tree
                  Ansatz.$fShowTree_$cshowsPrec
                  Ansatz.$fShowTree_$cshow
                  Ansatz.$fShowTree_$cshowList -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree1 :: Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Ansatz.Tree) -> Ansatz.$w$cshowsPrec 0# w) -}
a29a7c53ab4cca2d2f413a3799bfe0f6
  $fShowTree2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshow :: Ansatz.Tree -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Ansatz.Tree) ->
                 Ansatz.$fShowTree_$cshowsPrec
                   Ansatz.$fShowTree2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshowList :: [Ansatz.Tree] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Ansatz.Tree]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Ansatz.Tree Ansatz.$fShowTree1 ls s) -}
9052089a7aebda6d19da6177daa962a1
  $fShowTree_$cshowsPrec ::
    GHC.Types.Int -> Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Ansatz.Tree) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Ansatz.$w$cshowsPrec ww1 w1 }) -}
93adf8a89aa52843bec5314631f1f3a0
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  Ansatz.$s$fEq(,)_$s$fEq(,)_$c/= -}
c9a387433575b340b68c3abc8df6b8e8
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int))
                   (y :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
b548dc22626da76d18036d4541cede6b
  $sfromList ::
    [GHC.Types.Int] -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ GHC.Types.Int
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x of dt { GHC.Types.I# ipv ->
                           Data.Set.Internal.Bin
                             @ GHC.Types.Int
                             1#
                             dt
                             (Data.Set.Internal.Tip @ GHC.Types.Int)
                             (Data.Set.Internal.Tip @ GHC.Types.Int) }
                        : ipv ipv1
                        -> case x of wild2 { GHC.Types.I# x1 ->
                           case ipv of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x1 y of lwild {
                             DEFAULT
                             -> Ansatz.$wgo1
                                  1#
                                  (Data.Set.Internal.Bin
                                     @ GHC.Types.Int
                                     1#
                                     wild2
                                     (Data.Set.Internal.Tip @ GHC.Types.Int)
                                     (Data.Set.Internal.Tip @ GHC.Types.Int))
                                  wild1
                             1#
                             -> Ansatz.$sfromList_go4
                                  (Data.Set.Internal.Bin
                                     @ GHC.Types.Int
                                     1#
                                     wild2
                                     (Data.Set.Internal.Tip @ GHC.Types.Int)
                                     (Data.Set.Internal.Tip @ GHC.Types.Int))
                                  wild1 } } } } }) -}
97920bd554f1642f232ce6472345754d
  $sfromList_go4 ::
    Data.Set.Internal.Set GHC.Types.Int
    -> [GHC.Types.Int] -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c028212e6a2ffb80e86087c947186bf6
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2033514455733432812##
                   18002265259541182205##
                   Ansatz.$trModule
                   Ansatz.$tc'Leaf2
                   0#
                   Ansatz.$tc'Leaf1) -}
6bcc49d7dc3cb017711ed47330f3ce74
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2f6bf5ac5a76e13f7b7b413319d278e5
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tc'Leaf3) -}
ecf6b35a2a13b56d82626fc04822b076
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
1d3e7b8c8e5f4570ea6f96cffad30c5a
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8484511398144826853##
                   8047462201378559702##
                   Ansatz.$trModule
                   Ansatz.$tc'Node2
                   0#
                   Ansatz.$tc'Node1) -}
45b9bfa2787704e91e73bb3e3d5e4f89
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6d7b3a56f93ef1eec3f27debfb6cd539
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tc'Node3) -}
3b54b7f7dd91aff44742e7b3be2d3fb7
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
5d21e82209cf6e1a02c3a4b701b1a61d
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15185055251514789673##
                   10103094257428114360##
                   Ansatz.$trModule
                   Ansatz.$tcTree1
                   0#
                   GHC.Types.krep$*) -}
62049c79d96dd197f51dc9e2aaf04956
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$tcTree2) -}
670096d934b3bc4b8ed7af231a93f0fb
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
b91f634ffb12f6062519c5bfa9ef14eb
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Ansatz.$trModule3
                   Ansatz.$trModule1) -}
efc641f831a00a4f54bf971870c48acb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$trModule2) -}
c3228c1332902a45eac2af8a83dab40c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ansatz"#) -}
f3763ba4635ccf1cc7ccc046ca5af206
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ansatz.$trModule4) -}
405fc588e2932382c2db604859696980
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
9052089a7aebda6d19da6177daa962a1
  $w$cshowsPrec :: GHC.Prim.Int# -> Ansatz.Tree -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
5cf00763d47f238c49e29ceabddf5cbc
  $w$sgo3 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int
    -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
b916b0e1cc3fa7ea2828b1acaeddc965
  $wgo1 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int
    -> [GHC.Types.Int]
    -> Data.Set.Internal.Set GHC.Types.Int
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
06408f3e54b6ee1c26a9d67c6b106c8b
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
547a4a3d91ef0366afafa8f0debc9aad
  $wlvl ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.GT 1# -> GHC.Classes.compareInt ww1 ww3 }
                   1# -> GHC.Types.LT }) -}
354d6fb1094c4d8e1958811937236204
  type Edge = (GHC.Types.Int, GHC.Types.Int)
a456c151c9e277d0f28775b01686b8a7
  type Forest = Data.Sequence.Internal.Seq Ansatz.Tree
edc911a4fd3a327199cdf82382a0ae98
  type Root = GHC.Types.Int
9052089a7aebda6d19da6177daa962a1
  data Tree
    = Leaf GHC.Types.Int
    | Node GHC.Types.Int (Data.Sequence.Internal.Seq Ansatz.Tree)
fdcfec767009d3cd2156df4fbc07fb58
  getAllInds ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 GHC.List.filter
                   @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                   (\ (x :: Data.Sequence.Internal.Seq GHC.Types.Int) ->
                    Ansatz.getAllInds3 x symList)
                     `cast`
                   (<Data.Sequence.Internal.Seq GHC.Types.Int>_R
                    ->_R Data.Semigroup.Internal.N:All[0])
                   (Ansatz.getTopSortsSeq
                      (Ansatz.getAllInds1 edges roots)
                        `cast`
                      (Sym (Data.Sequence.Internal.N:Seq[0] <Ansatz.Tree>_R)))) -}
0ceec920ed8346f470574a265b867bc0
  getAllInds1 ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> Data.Sequence.Internal.FingerTree
         (Data.Sequence.Internal.Elem Ansatz.Tree)
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (edges :: [Ansatz.Edge]) (leafs :: [Ansatz.Root]) ->
                 let {
                   z :: [Ansatz.Tree]
                   = letrec {
                       go3 :: [Ansatz.Tree]
                              -> Data.Set.Internal.Set GHC.Types.Int -> [Ansatz.Tree]
                         {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                       = \ (z' :: [Ansatz.Tree])
                           (ds :: Data.Set.Internal.Set GHC.Types.Int) ->
                         case ds of wild {
                           Data.Set.Internal.Bin dt x l r
                           -> go3
                                (GHC.Types.: @ Ansatz.Tree (Ansatz.mkTree x edges) (go3 z' r))
                                l
                           Data.Set.Internal.Tip -> z' }
                     } in
                     let {
                       sndNodes :: Data.Set.Internal.Set GHC.Types.Int
                       = Ansatz.$sfromList
                           (GHC.Base.map
                              @ (GHC.Types.Int, GHC.Types.Int)
                              @ GHC.Types.Int
                              Ansatz.getAllInds2
                              edges)
                     } in
                     letrec {
                       go :: [(GHC.Types.Int, GHC.Types.Int)] -> [GHC.Types.Int]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ GHC.Types.Int
                           : y ys
                           -> case y of wild1 { (,) a b ->
                              case a of ww { GHC.Types.I# ww1 ->
                              case Ansatz.$wgo3 ww1 sndNodes of wild2 {
                                GHC.Types.False -> GHC.Types.: @ GHC.Types.Int ww (go ys)
                                GHC.Types.True -> go ys } } } }
                     } in
                     go3 (GHC.Types.[] @ Ansatz.Tree) (Ansatz.$sfromList (go edges))
                 } in
                 letrec {
                   go :: [GHC.Types.Int] -> [Ansatz.Tree]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> z
                       : y ys -> GHC.Types.: @ Ansatz.Tree (Ansatz.Leaf y) (go ys) }
                 } in
                 Data.Sequence.Internal.$fIsListSeq_mkTree
                   @ Ansatz.Tree
                   @ Ansatz.Tree
                   (go leafs)
                     `cast`
                   ([Sym (Data.Sequence.Internal.N:Elem[0] <Ansatz.Tree>_R)])_R) -}
873230593a4f1427685f02b34d0b96c3
  getAllInds2 :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case ds of wild { (,) a b -> b }) -}
88bff57b1c88446f1277047cf97b00f4
  getAllInds3 ::
    Data.Sequence.Internal.Seq GHC.Types.Int
    -> [(GHC.Types.Int, GHC.Types.Int)] -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (seq :: Data.Sequence.Internal.Seq GHC.Types.Int)
                   (list :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 letrec {
                   go :: [(GHC.Types.Int, GHC.Types.Int)]
                         -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> case y of wild1 { (,) i j ->
                          case i of wild2 { GHC.Types.I# x ->
                          case j of wild3 { GHC.Types.I# x1 ->
                          case Data.Sequence.Internal.$windex
                                 @ GHC.Types.Int
                                 seq
                                 (GHC.Prim.-# x 1#) of wild4 { GHC.Types.I# x2 ->
                          case Data.Sequence.Internal.$windex
                                 @ GHC.Types.Int
                                 seq
                                 (GHC.Prim.-# x1 1#) of wild5 { GHC.Types.I# y1 ->
                          case GHC.Prim.<# x2 y1 of lwild {
                            DEFAULT
                            -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                            1# -> go ys } } } } } } }
                 } in
                 go list) -}
e3e05f4bb277a21977b25f8b238155bf
  getAllIndsInverse ::
    [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 let {
                   topSorts :: [Data.Sequence.Internal.Seq GHC.Types.Int]
                   = Ansatz.getTopSortsSeq
                       (Ansatz.getAllInds1 edges roots)
                         `cast`
                       (Sym (Data.Sequence.Internal.N:Seq[0] <Ansatz.Tree>_R))
                 } in
                 let {
                   lvl15 :: Data.Sequence.Internal.FingerTree
                              (Data.Sequence.Internal.Elem GHC.Types.Int)
                   = case (GHC.List.$w!!
                             @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                             topSorts
                             0#)
                            `cast`
                          (Data.Sequence.Internal.N:Seq[0] <GHC.Types.Int>_R) of wild {
                       Data.Sequence.Internal.EmptyT -> Ansatz.getAllIndsInverse3
                       Data.Sequence.Internal.Single x -> Ansatz.getAllIndsInverse2
                       Data.Sequence.Internal.Deep dt ds1 ds2 ds3
                       -> Data.Sequence.Internal.$fIsListSeq_mkTree
                            @ GHC.Types.Int
                            @ GHC.Types.Int
                            (GHC.Enum.eftInt 1# dt)
                              `cast`
                            ([Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R)])_R }
                 } in
                 letrec {
                   go :: [Data.Sequence.Internal.Seq GHC.Types.Int]
                         -> [Data.Sequence.Internal.Seq GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Data.Sequence.Internal.Seq GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                       : y ys
                       -> case (Ansatz.getAllInds3 y symList)
                                 `cast`
                               (Data.Semigroup.Internal.N:All[0]) of wild1 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> GHC.Types.:
                                 @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                                 (Data.Sequence.Internal.$fFunctorSeq_$cfmap
                                    @ (Data.Sequence.Internal.Elem (GHC.Types.Int, GHC.Types.Int))
                                    @ (Data.Sequence.Internal.Elem GHC.Types.Int)
                                    (Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int)
                                      `cast`
                                    (Sym (Data.Sequence.Internal.N:Elem[0]
                                              <(GHC.Types.Int, GHC.Types.Int)>_R)
                                     ->_R Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R))
                                    (Data.Sequence.Internal.Sorting.sortBy
                                       @ (GHC.Types.Int, GHC.Types.Int)
                                       Ansatz.getAllIndsInverse1
                                       (Data.Sequence.Internal.zipWith
                                          @ GHC.Types.Int
                                          @ GHC.Types.Int
                                          @ (GHC.Types.Int, GHC.Types.Int)
                                          (GHC.Tuple.(,) @ GHC.Types.Int @ GHC.Types.Int)
                                          y
                                          lvl15
                                            `cast`
                                          (Sym (Data.Sequence.Internal.N:Seq[0]
                                                    <GHC.Types.Int>_R))))
                                      `cast`
                                    (Data.Sequence.Internal.N:Seq[0]
                                         <(GHC.Types.Int, GHC.Types.Int)>_R))
                                   `cast`
                                 (Sym (Data.Sequence.Internal.N:Seq[0] <GHC.Types.Int>_R))
                                 (go ys) } }
                 } in
                 go topSorts) -}
7ea26508759726f0a45b0bbd45378e26
  getAllIndsInverse1 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { (,) ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Ansatz.$wlvl ww4 ww2 ww9 ww7 } } } }) -}
b0b4bcbc782b22d40af2fbcfae52bee3
  getAllIndsInverse2 ::
    Data.Sequence.Internal.FingerTree
      (Data.Sequence.Internal.Elem GHC.Types.Int)
  {- Unfolding: (Data.Sequence.Internal.$fIsListSeq_mkTree
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   (GHC.Enum.eftInt 1# 1#)
                     `cast`
                   ([Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R)])_R) -}
27967ee56e1f10a8ab86b549c5fbc89f
  getAllIndsInverse3 ::
    Data.Sequence.Internal.FingerTree
      (Data.Sequence.Internal.Elem GHC.Types.Int)
  {- Unfolding: (Data.Sequence.Internal.$fIsListSeq_mkTree
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   (GHC.Enum.eftInt 1# 0#)
                     `cast`
                   ([Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R)])_R) -}
422ef2f66d3ba6211872917c2803609d
  getAllIndsLabel ::
    GHC.Base.String
    -> [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U><L,U><S,1*U><L,U>,
     Unfolding: (\ (inds :: GHC.Base.String)
                   (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 let {
                   m :: Data.IntMap.Internal.IntMap GHC.Types.Char
                   = Data.IntMap.Strict.fromList1
                       @ GHC.Types.Char
                       (Data.IntMap.Internal.Nil @ GHC.Types.Char)
                       (Ansatz.getAllIndsLabel_go 1# inds)
                 } in
                 let {
                   lvl15 :: GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 2, Strictness: <L,1*U(U)><L,U> -}
                   = \ (x :: GHC.Types.Int) (ys :: [GHC.Types.Char])[OneShot] ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       (Data.IntMap.Internal.! @ GHC.Types.Char m x)
                       ys
                 } in
                 Data.OldList.unlines
                   (GHC.Base.map
                      @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                      @ [GHC.Types.Char]
                      (\ (x :: Data.Sequence.Internal.Seq GHC.Types.Int) ->
                       Data.Sequence.Internal.$fEq1Seq_$cfoldr
                         @ (Data.Sequence.Internal.Elem GHC.Types.Int)
                         @ [GHC.Types.Char]
                         lvl15
                           `cast`
                         (Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R)
                          ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R)
                         (GHC.Types.[] @ GHC.Types.Char)
                         x `cast` (Data.Sequence.Internal.N:Seq[0] <GHC.Types.Int>_R))
                      (Ansatz.getAllInds edges roots symList))) -}
b2c79ab5f32cfa90331a19303d6d35ec
  getAllIndsLabelInverse ::
    GHC.Base.String
    -> [Ansatz.Edge]
    -> [Ansatz.Root]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U><L,U><S,1*U><L,U>,
     Unfolding: (\ (inds :: GHC.Base.String)
                   (edges :: [Ansatz.Edge])
                   (roots :: [Ansatz.Root])
                   (symList :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 let {
                   m :: Data.IntMap.Internal.IntMap GHC.Types.Char
                   = Data.IntMap.Strict.fromList1
                       @ GHC.Types.Char
                       (Data.IntMap.Internal.Nil @ GHC.Types.Char)
                       (Ansatz.getAllIndsLabel_go 1# inds)
                 } in
                 let {
                   lvl15 :: GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 2, Strictness: <L,1*U(U)><L,U> -}
                   = \ (x :: GHC.Types.Int) (ys :: [GHC.Types.Char])[OneShot] ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       (Data.IntMap.Internal.! @ GHC.Types.Char m x)
                       ys
                 } in
                 Data.OldList.unlines
                   (GHC.Base.map
                      @ (Data.Sequence.Internal.Seq GHC.Types.Int)
                      @ [GHC.Types.Char]
                      (\ (x :: Data.Sequence.Internal.Seq GHC.Types.Int) ->
                       Data.Sequence.Internal.$fEq1Seq_$cfoldr
                         @ (Data.Sequence.Internal.Elem GHC.Types.Int)
                         @ [GHC.Types.Char]
                         lvl15
                           `cast`
                         (Sym (Data.Sequence.Internal.N:Elem[0] <GHC.Types.Int>_R)
                          ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R)
                         (GHC.Types.[] @ GHC.Types.Char)
                         x `cast` (Data.Sequence.Internal.N:Seq[0] <GHC.Types.Int>_R))
                      (Ansatz.getAllIndsInverse edges roots symList))) -}
30731938ac46a9632d986360f6be6810
  getAllIndsLabel_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Char)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
24672831fab0569817f3e0ae8aad08de
  getTopSortsSeq ::
    Ansatz.Forest -> [Data.Sequence.Internal.Seq GHC.Types.Int]
  {- Arity: 1, Strictness: <S,U> -}
d8bbdd5fdf4eef1087c8d90373bb817d
  indexPermSeq ::
    Data.Sequence.Internal.Seq GHC.Types.Int
    -> Data.IntMap.Internal.IntMap GHC.Types.Char -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (a :: Data.Sequence.Internal.Seq GHC.Types.Int)
                   (b :: Data.IntMap.Internal.IntMap GHC.Types.Char) ->
                 let {
                   $j :: GHC.Base.String <join 0>
                   = GHC.CString.unpackAppendCString#
                       Ansatz.indexPermSeq6
                       (case Data.Sequence.Internal.$fEq1Seq_$cfoldr
                               @ (Data.Sequence.Internal.Elem Data.IntSet.Internal.Key)
                               @ (GHC.Types.Int -> [GHC.Types.Char])
                               (\ (x :: Data.IntSet.Internal.Key)
                                  (g :: GHC.Types.Int -> [GHC.Types.Char])[OneShot]
                                  (i :: GHC.Types.Int) ->
                                case i of i1 { GHC.Types.I# ipv ->
                                GHC.Types.:
                                  @ GHC.Types.Char
                                  (Data.IntMap.Internal.! @ GHC.Types.Char b x)
                                  (g (GHC.Types.I# (GHC.Prim.+# ipv 1#))) })
                                 `cast`
                               (Sym (Data.Sequence.Internal.N:Elem[0]
                                         <Data.IntSet.Internal.Key>_R)
                                ->_R <(GHC.Types.Int -> [GHC.Types.Char])
                                      -> GHC.Types.Int -> [GHC.Types.Char]>_R)
                               Ansatz.indexPermSeq5
                               a `cast`
                               (Data.Sequence.Internal.N:Seq[0] <Data.IntSet.Internal.Key>_R)
                               Ansatz.$fShowTree2 of wild {
                          [] -> Ansatz.indexPermSeq3
                          : x xs
                          -> GHC.Base.++_$s++
                               @ GHC.Types.Char
                               Ansatz.indexPermSeq3
                               x
                               (Data.OldList.prependToAll
                                  @ GHC.Types.Char
                                  Ansatz.indexPermSeq2
                                  xs) })
                 } in
                 case a `cast`
                      (Data.Sequence.Internal.N:Seq[0] <GHC.Types.Int>_R) of wild {
                   Data.Sequence.Internal.EmptyT
                   -> case Data.IntMap.Internal.$wgo @ GHC.Types.Char 0# b of ww {
                        DEFAULT -> Ansatz.indexPermSeq1 0# -> $j }
                   Data.Sequence.Internal.Single x
                   -> case Data.IntMap.Internal.$wgo @ GHC.Types.Char 0# b of ww {
                        DEFAULT -> Ansatz.indexPermSeq1 1# -> $j }
                   Data.Sequence.Internal.Deep dt ds1 ds2 ds3
                   -> case Data.IntMap.Internal.$wgo
                             @ GHC.Types.Char
                             0#
                             b of ww { DEFAULT ->
                      case GHC.Prim./=# dt ww of lwild {
                        DEFAULT -> $j 1# -> Ansatz.indexPermSeq1 } } }) -}
4ee44ebdd11428950322aae4aa2fd06d
  indexPermSeq1 :: GHC.Base.String
  {- Strictness: x -}
a7a60c65c99ca97691ec61b68321022b
  indexPermSeq2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ','#) -}
4775a6986c0c5bac189e51598cac2766
  indexPermSeq3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ansatz.indexPermSeq4) -}
cb3ce68c61114d9a68b98d88e71158df
  indexPermSeq4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("]"#) -}
6349c485f2d2e53f1dc97ac100a2d7aa
  indexPermSeq5 :: GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Int) -> GHC.Types.[] @ GHC.Types.Char) -}
38149d66145248010042bf070afed8c1
  indexPermSeq6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("["#) -}
b063376525dccbf318de1874d8e86141
  mkIndMap ::
    GHC.Base.String -> Data.IntMap.Internal.IntMap GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (inds :: GHC.Base.String) ->
                 Data.IntMap.Strict.fromList1
                   @ GHC.Types.Char
                   (Data.IntMap.Internal.Nil @ GHC.Types.Char)
                   (Ansatz.getAllIndsLabel_go 1# inds)) -}
5a5868224ebdda63b3260af933f45150
  mkTree :: Ansatz.Root -> [Ansatz.Edge] -> Ansatz.Tree
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,U> -}
instance [safe] GHC.Show.Show [Ansatz.Tree] = Ansatz.$fShowTree
"SPEC/Ansatz $fEq(,) @ Int @ Int" [orphan] forall (v1 :: GHC.Classes.Eq
                                                           GHC.Types.Int)
                                                  (v :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int v v1
  = Ansatz.$s$fEq(,)
"SPEC/Ansatz $fEq(,)_$c/= @ Int @ Int" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                   GHC.Types.Int)
                                                       ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Ansatz.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Ansatz fromList @ Int" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                         GHC.Types.Int)
  Data.Set.Internal.fromList @ GHC.Types.Int $dOrd
  = Ansatz.$sfromList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

