
==================== FINAL INTERFACE ====================
2018-10-05 22:34:31.538552 UTC

interface main:Ivar 8043
  interface hash: 311b2bf88120680e3ed9ae454cbcabca
  ABI hash: 59d07a95b67596bdbcd852778d385604
  export-list hash: 99536c1169a3d98973bcc51248b50ec9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 707c86cfbee6a9c65f08462953a21ad8
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ivar.addIvar
  Ivar.constrAllIvars
  Ivar.mkConstIvar
  Ivar.mkIvarRandom
  Ivar.number2Ivar
  Ivar.sMultIvar
  Ivar.showIvar
  Ivar.showIvarRational
  Ivar.subIvar
  Ivar.Ivar{Ivar.Ivar}
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0 primitive-0.6.3.0 random-1.1 tf-random-0.5
                      time-1.8.0.2 transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.IntMap.Internal ef73a09d9589b16c95e337bc0715aa57
import  -/  containers-0.5.11.0:Data.IntMap.Strict 79a3c61ca2c76eb71c4304029717e288
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  tf-random-0.5:System.Random.TF 8abc0839ff798088d7b0fe5da790c9f8
6fb5b1c62e6ccfd9020c45c8471a027a
  $fEqIvar :: GHC.Classes.Eq a => GHC.Classes.Eq (Ivar.Ivar a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Ivar.Ivar a)
                  (Ivar.$fEqIvar_$c== @ a v)
                  (Ivar.$fEqIvar_$c/= @ a v) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fEqIvar_$c/= ::
    GHC.Classes.Eq a => Ivar.Ivar a -> Ivar.Ivar a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Ivar.Ivar a)
                   (y :: Ivar.Ivar a) ->
                 case x of wild { Ivar.Ivar a1 a2 ->
                 case y of wild1 { Ivar.Ivar b1 b2 ->
                 case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case Data.IntMap.Internal.equal @ a $dEq a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fEqIvar_$c== ::
    GHC.Classes.Eq a => Ivar.Ivar a -> Ivar.Ivar a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Ivar.Ivar a)
                   (w2 :: Ivar.Ivar a) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 case w2 of ww3 { Ivar.Ivar ww4 ww5 ->
                 Ivar.$w$c== @ a w ww1 ww2 ww4 ww5 } }) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fFunctorIvar :: GHC.Base.Functor Ivar.Ivar
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Ivar.Ivar Ivar.$fFunctorIvar_$cfmap Ivar.$fFunctorIvar_$c<$ -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fFunctorIvar_$c<$ :: a -> Ivar.Ivar b -> Ivar.Ivar a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w1 :: Ivar.Ivar b) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 case Ivar.$w$c<$ @ a @ b w ww2 of ww3 { (#,#) ww4 ww5 ->
                 Ivar.Ivar @ a ww4 ww5 } }) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fFunctorIvar_$cfmap :: (a -> b) -> Ivar.Ivar a -> Ivar.Ivar b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Ivar.Ivar a) ->
                 case ds of wild { Ivar.Ivar a1 map ->
                 Ivar.Ivar @ b (f a1) (Data.IntMap.Strict.map @ a @ b f map) }) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fShowIvar :: GHC.Show.Show a => GHC.Show.Show (Ivar.Ivar a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Ivar.Ivar a)
                  (Ivar.$fShowIvar_$cshowsPrec @ a v)
                  (Ivar.$fShowIvar_$cshow @ a v)
                  (Ivar.$fShowIvar_$cshowList @ a v) -}
4bafc420832853c33e7f17a883708a97
  $fShowIvar1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
2b461e4d0b940b10b6fc6f9027766f83
  $fShowIvar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ivar "#) -}
73fadfae94b58371da0ad8561a7251af
  $fShowIvar3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fShowIvar_$cshow ::
    GHC.Show.Show a => Ivar.Ivar a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Ivar.Ivar a) ->
                 Ivar.$fShowIvar_$cshowsPrec
                   @ a
                   $dShow
                   Ivar.$fShowIvar1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fShowIvar_$cshowList ::
    GHC.Show.Show a => [Ivar.Ivar a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Ivar.Ivar a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Ivar.Ivar a)
                   (Ivar.$fShowIvar_$cshowsPrec @ a $dShow Ivar.$fShowIvar1)
                   ls
                   s) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  $fShowIvar_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Ivar.Ivar a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Ivar.Ivar a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Ivar.Ivar ww3 ww4 ->
                 Ivar.$w$cshowsPrec @ a w ww1 ww3 ww4 } }) -}
0111b0bc0c9d1734a2d07eec61cd4e38
  $tc'Ivar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9934823870565832890##
                   385532488050332337##
                   Ivar.$trModule
                   Ivar.$tc'Ivar2
                   1#
                   Ivar.$tc'Ivar1) -}
7ecb1fc348822c024f896a6a9b35182e
  $tc'Ivar1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0101f6f17fecccee1b827abb73bbab86
  $tc'Ivar2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ivar.$tc'Ivar3) -}
a70b5c8493014457eae5b1e815e5b8bf
  $tc'Ivar3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ivar"#) -}
80c85c2c62bb0d8658977bcc016960e1
  $tcIvar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8128594365458056779##
                   1303347348194250438##
                   Ivar.$trModule
                   Ivar.$trModule1
                   0#
                   GHC.Types.krep$*Arr*) -}
d55a831b5134eaa335eb64607eb6ef4e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Ivar.$trModule3 Ivar.$trModule1) -}
f6e6604583332231a2392eeedf44b5f6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ivar.$trModule2) -}
0f6ecf80fc28afd481b2da12a53083aa
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ivar"#) -}
659bffece711e4ce656561a00da1a852
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ivar.$trModule4) -}
9fbbafbb4acf2283ef4160772ed06205
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
600190208cce4faa24f85e97d5371dbd
  $w$c<$ ::
    a
    -> Data.IntMap.Internal.IntMap b
    -> (# a, Data.IntMap.Internal.IntMap a #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a)
                   (ww :: Data.IntMap.Internal.IntMap b) ->
                 (# w,
                    letrec {
                      go :: Data.IntMap.Internal.IntMap b
                            -> Data.IntMap.Internal.IntMap a
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: Data.IntMap.Internal.IntMap b) ->
                        case ds of wild {
                          Data.IntMap.Internal.Bin dt dt1 l r
                          -> case go l of dt2 { DEFAULT ->
                             case go r of dt3 { DEFAULT ->
                             Data.IntMap.Internal.Bin @ a dt dt1 dt2 dt3 } }
                          Data.IntMap.Internal.Tip dt x
                          -> case w of vx { DEFAULT -> Data.IntMap.Internal.Tip @ a dt vx }
                          Data.IntMap.Internal.Nil -> Data.IntMap.Internal.Nil @ a }
                    } in
                    go ww #)) -}
aeebe53ce285b4d3ec24a0e006c0a77c
  $w$c== ::
    GHC.Classes.Eq a =>
    a
    -> Data.IntMap.Internal.IntMap a
    -> a
    -> Data.IntMap.Internal.IntMap a
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: Data.IntMap.Internal.IntMap a)
                   (ww2 :: a)
                   (ww3 :: Data.IntMap.Internal.IntMap a) ->
                 case GHC.Classes.== @ a w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> Data.IntMap.Internal.equal @ a w ww1 ww3 }) -}
48f4fb559bcf66591982636b7f12710e
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> a -> Data.IntMap.Internal.IntMap a -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: Data.IntMap.Internal.IntMap a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Ivar.$fShowIvar3 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Data.IntMap.Internal.$w$cshowsPrec @ a w 11# ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Ivar.$fShowIvar2
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Ivar.$fShowIvar2
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
983768900f3a603510b628808f196f41
  $wconstrAllIvars :: GHC.Num.Num a => GHC.Prim.Int# -> [Ivar.Ivar a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.># 1# ww of lwild {
                   DEFAULT
                   -> let {
                        lvl4 :: a = GHC.Num.fromInteger @ a w Ivar.constrAllIvars2
                      } in
                      let {
                        lvl5 :: a = GHC.Num.fromInteger @ a w Ivar.constrAllIvars1
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> [Ivar.Ivar a]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ (Ivar.Ivar a)
                            (Ivar.Ivar
                               @ a
                               lvl4
                               (Data.IntMap.Strict.fromList1
                                  @ a
                                  (Data.IntMap.Internal.Nil @ a)
                                  (GHC.Types.:
                                     @ (GHC.Types.Int, a)
                                     (GHC.Types.I# x, lvl5)
                                     (GHC.Types.[] @ (GHC.Types.Int, a)))))
                            (case GHC.Prim.==# x ww of lwild1 {
                               DEFAULT -> go (GHC.Prim.+# x 1#)
                               1# -> GHC.Types.[] @ (Ivar.Ivar a) })
                      } in
                      go 1#
                   1# -> GHC.Types.[] @ (Ivar.Ivar a) }) -}
7b970cc4572bdd13a27343354e7194b0
  $wmkIvarRandom ::
    GHC.Num.Num a =>
    a
    -> Data.IntMap.Internal.IntMap a
    -> Data.IntMap.Internal.IntMap GHC.Types.Int
    -> a
  {- Arity: 4,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><L,U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: a)
                   (ww1 :: Data.IntMap.Internal.IntMap a)
                   (w1 :: Data.IntMap.Internal.IntMap GHC.Types.Int) ->
                 GHC.Num.+
                   @ a
                   w
                   ww
                   (GHC.Num.fromInteger
                      @ a
                      w
                      (case Data.IntMap.Strict.mapWithKey
                              @ a
                              @ GHC.Types.Int
                              (\ (k :: Data.IntSet.Internal.Key) (v :: a)[OneShot] ->
                               Data.IntMap.Internal.! @ GHC.Types.Int w1 k)
                              ww1 of wild {
                         DEFAULT
                         -> case Ivar.mkIvarRandom_go
                                   (GHC.Base.id @ GHC.Types.Int)
                                   wild
                                   Ivar.$fShowIvar1 of wild1 { GHC.Types.I# i ->
                            GHC.Integer.Type.smallInteger i }
                         Data.IntMap.Internal.Bin dt dt1 l r
                         -> case GHC.Prim.<# dt1 0# of lwild {
                              DEFAULT
                              -> case Ivar.mkIvarRandom_go
                                        (Ivar.mkIvarRandom_go (GHC.Base.id @ GHC.Types.Int) r)
                                        l
                                        Ivar.$fShowIvar1 of wild1 { GHC.Types.I# i ->
                                 GHC.Integer.Type.smallInteger i }
                              1#
                              -> case Ivar.mkIvarRandom_go
                                        (Ivar.mkIvarRandom_go (GHC.Base.id @ GHC.Types.Int) l)
                                        r
                                        Ivar.$fShowIvar1 of wild1 { GHC.Types.I# i ->
                                 GHC.Integer.Type.smallInteger i } } }))) -}
38a75e74f278301160c6d25de735171a
  $wshowIvar ::
    GHC.Show.Show a =>
    a -> Data.IntMap.Internal.IntMap a -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)L),U(A,C(U),A)><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: a)
                   (ww1 :: Data.IntMap.Internal.IntMap a) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Show.show @ a w ww)
                   (letrec {
                      go :: [GHC.Types.Char]
                            -> Data.IntMap.Internal.IntMap a -> [GHC.Types.Char]
                        {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                      = \ (z' :: [GHC.Types.Char])
                          (ds :: Data.IntMap.Internal.IntMap a) ->
                        case ds of wild {
                          Data.IntMap.Internal.Bin dt dt1 l r -> go (go z' r) l
                          Data.IntMap.Internal.Tip dt x
                          -> GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Show.show @ a w x)
                                  (GHC.CString.unpackAppendCString#
                                     Ivar.showIvar2
                                     (GHC.CString.unpackAppendCString#
                                        Ivar.showIvar1
                                        (case GHC.Show.$wshowSignedInt
                                                0#
                                                dt
                                                (GHC.Types.[]
                                                   @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                         GHC.Types.: @ GHC.Types.Char ww5 ww6 }))))
                               z'
                          Data.IntMap.Internal.Nil -> z' }
                    } in
                    case ww1 of wild {
                      DEFAULT -> go (GHC.Types.[] @ GHC.Types.Char) wild
                      Data.IntMap.Internal.Bin dt dt1 l r
                      -> case GHC.Prim.<# dt1 0# of lwild {
                           DEFAULT -> go (go (GHC.Types.[] @ GHC.Types.Char) r) l
                           1# -> go (go (GHC.Types.[] @ GHC.Types.Char) l) r } })) -}
89a9853c2a06fe4a1edeec69782dd28a
  $wshowIvarRational ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> Data.IntMap.Internal.IntMap GHC.Real.Rational
    -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 3, Strictness: <L,U><S,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Integer.Type.Integer)
                   (ww1 :: GHC.Integer.Type.Integer)
                   (ww2 :: Data.IntMap.Internal.IntMap GHC.Real.Rational) ->
                 case GHC.Integer.Type.eqInteger#
                        ww1
                        Ivar.constrAllIvars2 of wild1 {
                   DEFAULT
                   -> case GHC.Integer.Type.quotRemInteger
                             ww
                             ww1 of ds { (#,#) ipv ipv1 ->
                      case GHC.Show.$w$cshowsPrec4
                             0#
                             ipv
                             (GHC.Types.[] @ GHC.Types.Char) of ww3 { (#,#) ww4 ww5 ->
                      case GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (case ww2 of wild {
                                DEFAULT
                                -> Ivar.showIvarRational_go (GHC.Types.[] @ GHC.Types.Char) wild
                                Data.IntMap.Internal.Bin dt dt1 l r
                                -> case GHC.Prim.<# dt1 0# of lwild {
                                     DEFAULT
                                     -> Ivar.showIvarRational_go
                                          (Ivar.showIvarRational_go
                                             (GHC.Types.[] @ GHC.Types.Char)
                                             r)
                                          l
                                     1#
                                     -> Ivar.showIvarRational_go
                                          (Ivar.showIvarRational_go
                                             (GHC.Types.[] @ GHC.Types.Char)
                                             l)
                                          r } })
                             ww4
                             ww5 of ww6 { : ww7 ww8 ->
                      (# ww7, ww8 #) } } }
                   1#
                   -> case GHC.Real.divZeroError
                      ret_ty (# GHC.Types.Char, [GHC.Types.Char] #)
                      of {} }) -}
a6c715579352849d521617c0dedde492
  $wsubIvar ::
    GHC.Num.Num a =>
    a
    -> Data.IntMap.Internal.IntMap a
    -> a
    -> Data.IntMap.Internal.IntMap a
    -> (# a, Data.IntMap.Internal.IntMap a #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,1*C1(C(U)),1*C1(U),A,A,1*C1(U))><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: a)
                   (ww1 :: Data.IntMap.Internal.IntMap a)
                   (ww2 :: a)
                   (ww3 :: Data.IntMap.Internal.IntMap a) ->
                 let {
                   f :: a -> a
                   = GHC.Num.*
                       @ a
                       w
                       (GHC.Num.negate
                          @ a
                          w
                          (GHC.Num.fromInteger @ a w Ivar.constrAllIvars1))
                 } in
                 (# GHC.Num.+ @ a w ww (f ww2),
                    Data.IntMap.Strict.unionWithKey
                      @ a
                      (\ (ds :: Data.IntSet.Internal.Key)
                         (x :: a)[OneShot]
                         (y :: a)[OneShot] ->
                       GHC.Num.+ @ a w x y)
                      ww1
                      (Data.IntMap.Strict.map @ a @ a f ww3) #)) -}
6fb5b1c62e6ccfd9020c45c8471a027a
  data Ivar a = Ivar a (Data.IntMap.Internal.IntMap a)
05c03b458f32d9cc7a5d25e2e9ea4e41
  addIvar ::
    GHC.Num.Num a => Ivar.Ivar a -> Ivar.Ivar a -> Ivar.Ivar a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Ivar.Ivar a)
                   (w2 :: Ivar.Ivar a) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 case w2 of ww3 { Ivar.Ivar ww4 ww5 ->
                 Ivar.Ivar
                   @ a
                   (GHC.Num.+ @ a w ww1 ww4)
                   (Data.IntMap.Strict.unionWithKey
                      @ a
                      (\ (ds :: Data.IntSet.Internal.Key)
                         (x :: a)[OneShot]
                         (y :: a)[OneShot] ->
                       GHC.Num.+ @ a w x y)
                      ww2
                      ww5) } }) -}
2e8311e6dfb6ae097f0452c25b09bf82
  constrAllIvars :: GHC.Num.Num a => GHC.Types.Int -> [Ivar.Ivar a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Ivar.$wconstrAllIvars @ a w ww1 }) -}
fb6cb697ce48ea18dbb61f813d546d75
  constrAllIvars1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
c65d130cc7fb2bce37fccd555d3bc2cf
  constrAllIvars2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
3e3db0384e6c18ba4849c316c911d6a4
  mkConstIvar :: a -> Ivar.Ivar a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (a1 :: a) ->
                 Ivar.Ivar @ a a1 (Data.IntMap.Internal.Nil @ a)) -}
e88d2a95c7d222674da4a0f89ebfa84b
  mkIvarRandom ::
    GHC.Num.Num a =>
    Ivar.Ivar a -> Data.IntMap.Internal.IntMap GHC.Types.Int -> a
  {- Arity: 3,
     Strictness: <S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U(U,1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Ivar.Ivar a)
                   (w2 :: Data.IntMap.Internal.IntMap GHC.Types.Int) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 Ivar.$wmkIvarRandom @ a w ww1 ww2 w2 }) -}
92b730a0a32b3732c1976e0fc44e586e
  mkIvarRandom_go ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> Data.IntMap.Internal.IntMap GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U(U))><S,1*U><L,U(U)> -}
b988f0c628c785064134f5698bb06f7d
  number2Ivar :: GHC.Num.Num a => GHC.Types.Int -> Ivar.Ivar a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,1*U(U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 Ivar.Ivar
                   @ a
                   (GHC.Num.fromInteger @ a w Ivar.constrAllIvars2)
                   (case GHC.Num.fromInteger
                           @ a
                           w
                           Ivar.constrAllIvars1 of x1 { DEFAULT ->
                    case w1 of dt { GHC.Types.I# dt1 ->
                    Data.IntMap.Internal.Tip @ a dt1 x1 } })) -}
356c5596a99fee829bee8b24bdb79848
  sMultIvar :: GHC.Num.Num a => a -> Ivar.Ivar a -> Ivar.Ivar a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C(U)),A,A,A,A)><L,U><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: a) (w2 :: Ivar.Ivar a) ->
                 case w2 of ww { Ivar.Ivar ww1 ww2 ->
                 let {
                   f :: a -> a = GHC.Num.* @ a w w1
                 } in
                 Ivar.Ivar @ a (f ww1) (Data.IntMap.Strict.map @ a @ a f ww2) }) -}
bb26e3c0940b0694df5c5429fec01633
  showIvar :: GHC.Show.Show a => Ivar.Ivar a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)L),U(A,C(U),A)><S,1*U(U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Ivar.Ivar a) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 Ivar.$wshowIvar @ a w ww1 ww2 }) -}
95997ec92407676c05a575111630b2aa
  showIvar1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("V"#) -}
9f31f9dca04da7812499f5fb19451863
  showIvar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
86836b8b8b42e6bab13bd30c13c32c0f
  showIvarRational :: Ivar.Ivar GHC.Real.Rational -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(SS)L),1*U(1*U(U,U),1*U)>m2,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Ivar.Ivar GHC.Real.Rational) ->
                 case w of ww { Ivar.Ivar ww1 ww2 ->
                 case ww1 of ww3 { GHC.Real.:% ww4 ww5 ->
                 case Ivar.$wshowIvarRational ww4 ww5 ww2 of ww6 { (#,#) ww7 ww8 ->
                 GHC.Types.: @ GHC.Types.Char ww7 ww8 } } }) -}
713fcc34ece56c7f67a674a95eaca337
  showIvarRational_go ::
    [GHC.Types.Char]
    -> Data.IntMap.Internal.IntMap
         (GHC.Real.Ratio GHC.Integer.Type.Integer)
    -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
651916c589e6fcc1ed4a238713804e05
  subIvar ::
    GHC.Num.Num a => Ivar.Ivar a -> Ivar.Ivar a -> Ivar.Ivar a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),C(U),A,A,C(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Ivar.Ivar a)
                   (w2 :: Ivar.Ivar a) ->
                 case w1 of ww { Ivar.Ivar ww1 ww2 ->
                 case w2 of ww3 { Ivar.Ivar ww4 ww5 ->
                 case Ivar.$wsubIvar @ a w ww1 ww2 ww4 ww5 of ww6 { (#,#) ww7 ww8 ->
                 Ivar.Ivar @ a ww7 ww8 } } }) -}
instance GHC.Classes.Eq [Ivar.Ivar] = Ivar.$fEqIvar
instance GHC.Base.Functor [Ivar.Ivar] = Ivar.$fFunctorIvar
instance GHC.Show.Show [Ivar.Ivar] = Ivar.$fShowIvar
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

