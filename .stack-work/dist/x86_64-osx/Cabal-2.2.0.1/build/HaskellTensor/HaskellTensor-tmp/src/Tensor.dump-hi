
==================== FINAL INTERFACE ====================
2019-02-01 11:16:10.512636 UTC

interface main:Tensor 8043
  interface hash: 7001722456277b1a06b53390a7c22f8d
  ABI hash: c5dfa081ae5ad523bef39ca8def0f654
  export-list hash: af2b4fe26a34e82b11fcad14a4c891cb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 941ef95016433cfd417a6725e52dbf85
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tensor.aSymTensor
  Tensor.blockSymTensor
  Tensor.cyclicSymTensor
  Tensor.evalFullTensor
  Tensor.evalTensorVals
  Tensor.getVal
  Tensor.mkTensorfromF
  Tensor.mkTensorfromFZeros
  Tensor.mkTensorfromList
  Tensor.symTensor
  Tensor.tensorAdd
  Tensor.tensorContractWith_19
  Tensor.tensorContractWith_20
  Tensor.tensorContractWith_3
  Tensor.tensorContractWith_9
  Tensor.tensorIndList
  Tensor.tensorProductNew
  Tensor.tensorProductNumeric
  Tensor.tensorProductNumeric2
  Tensor.tensorProductWith
  Tensor.tensorProductWith2
  Tensor.tensorSMult
  Tensor.tensorSub
  Tensor.tensorTranspose
  Tensor.unsafeGetVal
  Tensor.Tensor{Tensor.Tensor}
module dependencies: Index
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Proxy a80a60a2fdceabfeb4d110d23b808844
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Enum 8824828888f5a89ecc9e7c73f05f3151
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Read b9e6d20d40da8c8a12b566d22e1160e0
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:GHC.TypeNats 8f7c6aed0d8e1900cac5f62a9bc0fd0b
import  -/  base-4.11.1.0:Numeric.Natural da273ddb373e0510fde98e17e4aa338f
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:Text.ParserCombinators.ReadPrec d0ebf984ed486435a97481288b73febb
import  -/  base-4.11.1.0:Text.Read.Lex f8ad6f9ae74ae325ba69a4fa5c82aaca
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  containers-0.5.11.0:Data.Map.Strict 40ac55e8c7db7b7f0f7e3d9769233909
import  -/  containers-0.5.11.0:Data.Map.Strict.Internal 372117aaabc2f1ff2039eaf324fdb5c6
import  -/  containers-0.5.11.0:Data.Sequence 21c58838329d44e2dc13db7c04e3a8d8
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  Index 846d6195a6d682ebc4b5552893fd0d45
  exports: 57bd4ebf86e1ac997dd2a9c3171f207b
  Index f1b2e2d342d299287fa67a4a38056bc6
  Index d1cd1067a874dee8fab194e163b456d3
  checkInd b93eaef539611d2d7481eb661873462a
  combineIndex a4591e28842467efc69c3b51e77f6344
  cyclicSwapIndex a862547a81c94dbf587da2556e5bd661
  delContractionIndex_19 7f6965696a8db6a6f536be5b84267a41
  delContractionIndex_20 4ccb5bff760d5bf8b17f92b7fc00eb6e
  delContractionIndex_3 ec3f58a29cd145b9a39ce42b81e65c65
  delContractionIndex_9 7f40c5a1e7800d125294134bffa8bce1
  delInd 364200a1792f917b8846be69fb145294
  getRangeList 35c271ce9c33d7029e662d493b216f1d
  isContractionIndex 34fdc87b7af9294543faff137fc81fbb
  mkInd 0cd61b787d4cebc06b327004b370bff2
  swapBlockPosIndex ea88d38e4014f5f890a206149d798020
  swapPosIndex d767ccec479716c59cf65fc1599cbeb2
6ebce5ff137d1d5d966e303383d35759
  $fFunctorTensor ::
    GHC.Base.Functor (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ n1 :: GHC.Types.Nat
                      @ n2 :: GHC.Types.Nat
                      @ n3 :: GHC.Types.Nat
                      @ n4 :: GHC.Types.Nat
                      @ n5 :: GHC.Types.Nat
                      @ n6 :: GHC.Types.Nat
                      @ n7 :: GHC.Types.Nat
                      @ n8 :: GHC.Types.Nat.
                  @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8)
                  (Tensor.$fFunctorTensor_$cfmap
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8)
                  (Tensor.$fFunctorTensor_$c<$
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8) -}
6ebce5ff137d1d5d966e303383d35759
  $fFunctorTensor_$c<$ ::
    a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 b
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   @ b
                   (w :: a)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 b) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$w$c<$
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ a
                        @ b
                        w
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
6ebce5ff137d1d5d966e303383d35759
  $fFunctorTensor_$cfmap ::
    (a -> b)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case ds of wild { Tensor.Tensor tMap ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ b
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        f
                        tMap of dt { DEFAULT ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ b
                   dt } }) -}
6ebce5ff137d1d5d966e303383d35759
  $fReadTensor ::
    GHC.Read.Read a =>
    GHC.Read.Read (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ n1 :: GHC.Types.Nat
                      @ n2 :: GHC.Types.Nat
                      @ n3 :: GHC.Types.Nat
                      @ n4 :: GHC.Types.Nat
                      @ n5 :: GHC.Types.Nat
                      @ n6 :: GHC.Types.Nat
                      @ n7 :: GHC.Types.Nat
                      @ n8 :: GHC.Types.Nat
                      @ a
                      (v :: GHC.Read.Read a).
                  @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                  (Tensor.$fReadTensor_$creadsPrec
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v)
                  (Tensor.$fReadTensor_$creadList
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v)
                  (Tensor.$fReadTensor1
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Tensor.Tensor
                                     n1
                                     n2
                                     n3
                                     n4
                                     n5
                                     n6
                                     n7
                                     n8
                                     a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a>_R))
                  (Tensor.$fReadTensor_$creadListPrec
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v) -}
6ebce5ff137d1d5d966e303383d35759
  $fReadTensor1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$fRead()6
                   @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (\ (c :: Text.ParserCombinators.ReadPrec.Prec)
                      @ b1
                      (eta2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
                               -> Text.ParserCombinators.ReadP.P b1) ->
                    case c of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 10# of lwild {
                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                      1#
                      -> let {
                           lvl118 :: Text.ParserCombinators.ReadP.P b1
                           = let {
                               lvl119 :: Text.ParserCombinators.ReadP.P b1
                               = Data.Map.Internal.$fReadMap1
                                   @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                                   @ a
                                   (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                                   (Index.$fReadIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                                   $dRead
                                   Tensor.$fReadTensor4
                                   @ b1
                                   (\ (a1 :: Data.Map.Internal.Map
                                               (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                                    eta2
                                      (Tensor.$WTensor
                                         @ n1
                                         @ n2
                                         @ n3
                                         @ n4
                                         @ n5
                                         @ n6
                                         @ n7
                                         @ n8
                                         @ a
                                         a1))
                             } in
                             Text.Read.Lex.expect2
                               @ b1
                               (\ (a3 :: Text.Read.Lex.Lexeme) ->
                                case a3 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                                  Text.Read.Lex.Ident a1
                                  -> case GHC.Base.eqString a1 Tensor.$fReadTensor2 of wild2 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                                       GHC.Types.True -> lvl119 } })
                         } in
                         let {
                           k :: () -> Text.ParserCombinators.ReadP.P b1
                             {- Arity: 1, Strictness: <L,A>,
                                Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                           = \ (a3 :: ()) -> lvl118
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b1
                           (\ (a1 :: GHC.Base.String) ->
                            Text.ParserCombinators.ReadP.skipSpaces2 a1 @ b1 k) } })
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Tensor.Tensor
                                      n1
                                      n2
                                      n3
                                      n4
                                      n5
                                      n6
                                      n7
                                      n8
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Tensor.Tensor
                                                           n1 n2 n3 n4 n5 n6 n7 n8 a>_R))
                   eta
                   @ b
                   eta1) -}
78c7468d547d81efe8c9c60608f84c67
  $fReadTensor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tensor.$fReadTensor3) -}
8b1b336b046633706ed1472d1cba5668
  $fReadTensor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tensor"#) -}
a6dde5f0c53ca6a9814f1cf87be1966c
  $fReadTensor4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
6ebce5ff137d1d5d966e303383d35759
  $fReadTensor_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS
      [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]
                   (((GHC.Read.list
                        @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                        (Tensor.$fReadTensor1
                           @ n1
                           @ n2
                           @ n3
                           @ n4
                           @ n5
                           @ n6
                           @ n7
                           @ n8
                           @ a
                           $dRead)
                          `cast`
                        ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <Tensor.Tensor
                                           n1
                                           n2
                                           n3
                                           n4
                                           n5
                                           n6
                                           n7
                                           n8
                                           a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Tensor.Tensor
                                                                n1 n2 n3 n4 n5 n6 n7 n8 a>_R)))
                       `cast`
                     (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <[Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]>_R)
                       GHC.Read.$fRead()8)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <[Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]>_R)
                      @ [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]))) -}
6ebce5ff137d1d5d966e303383d35759
  $fReadTensor_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dRead :: GHC.Read.Read a) ->
                 GHC.Read.list
                   @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (Tensor.$fReadTensor1
                      @ n1
                      @ n2
                      @ n3
                      @ n4
                      @ n5
                      @ n6
                      @ n7
                      @ n8
                      @ a
                      $dRead)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Tensor.Tensor
                                      n1
                                      n2
                                      n3
                                      n4
                                      n5
                                      n6
                                      n7
                                      n8
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Tensor.Tensor
                                                           n1 n2 n3 n4 n5 n6 n7 n8 a>_R))) -}
6ebce5ff137d1d5d966e303383d35759
  $fReadTensor_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dRead :: GHC.Read.Read a)
                   (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (Tensor.$fReadTensor1
                      @ n1
                      @ n2
                      @ n3
                      @ n4
                      @ n5
                      @ n6
                      @ n7
                      @ n8
                      @ a
                      $dRead
                      n
                      @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)))) -}
6ebce5ff137d1d5d966e303383d35759
  $fShowTensor ::
    GHC.Show.Show a =>
    GHC.Show.Show (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C1(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ n1 :: GHC.Types.Nat
                      @ n2 :: GHC.Types.Nat
                      @ n3 :: GHC.Types.Nat
                      @ n4 :: GHC.Types.Nat
                      @ n5 :: GHC.Types.Nat
                      @ n6 :: GHC.Types.Nat
                      @ n7 :: GHC.Types.Nat
                      @ n8 :: GHC.Types.Nat
                      @ a
                      (v :: GHC.Show.Show a).
                  @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                  (Tensor.$fShowTensor_$cshowsPrec
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v)
                  (Tensor.$fShowTensor_$cshow
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v)
                  (Tensor.$fShowTensor_$cshowList
                     @ n1
                     @ n2
                     @ n3
                     @ n4
                     @ n5
                     @ n6
                     @ n7
                     @ n8
                     @ a
                     v) -}
737494dd887cc43ca1e040c11eb4e200
  $fShowTensor1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
22cdd232bf930dc0faa0b6cceff6d68b
  $fShowTensor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tensor.$fShowTensor3) -}
038bda6e6e33cc813e9b34b169d0a8c8
  $fShowTensor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tensor "#) -}
6ebce5ff137d1d5d966e303383d35759
  $fShowTensor_$cshow ::
    GHC.Show.Show a =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C1(U))),A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Tensor.$fShowTensor2
                   (Data.Map.Internal.$w$cshowsPrec
                      @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                      @ a
                      (Index.$fShowIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                      w
                      11#
                      ww1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
6ebce5ff137d1d5d966e303383d35759
  $fShowTensor_$cshowList ::
    GHC.Show.Show a =>
    [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (Tensor.$fShowTensor_$cshowsPrec
                      @ n1
                      @ n2
                      @ n3
                      @ n4
                      @ n5
                      @ n6
                      @ n7
                      @ n8
                      @ a
                      $dShow
                      Tensor.$fShowTensor1)
                   ls
                   s) -}
6ebce5ff137d1d5d966e303383d35759
  $fShowTensor_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,A)><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Tensor.Tensor ww3 ->
                 Tensor.$w$cshowsPrec
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   w
                   ww1
                   ww3 } }) -}
41d8a844014fb8db935a569855a81fe5
  $tc'Tensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12818042684598350646##
                   14291769805369570361##
                   Tensor.$trModule
                   Tensor.$tc'Tensor2
                   9#
                   Tensor.$tc'Tensor1) -}
5596a26efcd24c4c9dfe567f1a2f272c
  $tc'Tensor1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4ce00cdfd7748930d095a56929eb9141
  $tc'Tensor2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tensor.$tc'Tensor3) -}
35bcb15695cfd8740e67fd21fbf81243
  $tc'Tensor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Tensor"#) -}
60642b2e04db1020c1905be14ca422b6
  $tcTensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16721014749436762582##
                   10886807482571654239##
                   Tensor.$trModule
                   Tensor.$trModule1
                   0#
                   Tensor.$tcTensor1) -}
e9a7914fe5cca5a97176b51483defd45
  $tcTensor1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ea2f7ad074afcae6bf2f7e166df68900
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tensor.$trModule2
                   Tensor.$trModule1) -}
80d00e847b4c6df9fb7b292eabe2cb9f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tensor.$fReadTensor3) -}
8879edd1a36fabe0bbd0d1b29f5e4772
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tensor.$trModule3) -}
c37eba3fde3919614dc11de6523ea88d
  $trModule3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
dc6700735f2bb667e76a61fa82b3c3a5
  $w$c<$ ::
    a
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) b
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   @ b
                   (w :: a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) b) ->
                 letrec {
                   go8 :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) b
                          -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) b) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> case w of x' { DEFAULT ->
                          case go8 l of dt1 { DEFAULT ->
                          case go8 r of dt2 { DEFAULT ->
                          Data.Map.Internal.Bin
                            @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                            @ a
                            dt
                            kx
                            x'
                            dt1
                            dt2 } } }
                       Data.Map.Internal.Tip
                       -> Data.Map.Internal.Tip
                            @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                            @ a }
                 } in
                 case go8 ww of dt { DEFAULT -> (# dt #) }) -}
09c29bccb8e46280e9501843c16e5206
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,A)><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Data.Map.Internal.$w$cshowsPrec
                       @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                       @ a
                       (Index.$fShowIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                       w
                       11#
                       ww1
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Tensor.$fShowTensor2 (g x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Tensor.$fShowTensor2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
3e3f119caf2acf69ed341bad31f885b1
  $w$sfactorial :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
6fb18498c8050b7dd6ccfbc0846bbd7c
  $waSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 4,
     Strictness: <L,U(1*U(C(C1(U)),A,C(C(U)),C(U),A,A,C(U)),1*C1(C1(U)),A,A)><L,U(U)><L,U(U(U),U(U))><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 case Tensor.$wtensorTranspose
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ a
                        w1
                        w2
                        ww of ww1 { Unit# ww2 ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a w
                 } in
                 case Tensor.$wtensorSub
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        $dNum
                        ww
                        ww2 of ww3 { Unit# ww4 ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        (GHC.Num.*
                           @ a
                           $dNum
                           (GHC.Real./
                              @ a
                              w
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor2)
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor1)))
                        ww4 of dt { DEFAULT ->
                 (# dt #) } } }) -}
9fe660010b9a12be9431f0b6dd7e582e
  $wblockSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> ([GHC.Types.Int], [GHC.Types.Int])
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 4,
     Strictness: <L,U(1*U(1*C(C1(U)),A,1*C1(C(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U(U)><L,U(U,U)><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: ([GHC.Types.Int], [GHC.Types.Int]))
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 letrec {
                   go13 :: [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
                           -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                           -> [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (GHC.Types.:
                               @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)
                               (Index.swapBlockPosIndex
                                  @ n1
                                  @ n2
                                  @ n3
                                  @ n4
                                  @ n5
                                  @ n6
                                  @ n7
                                  @ n8
                                  w1
                                  w2
                                  kx,
                                x)
                               (go13 z' r))
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 case Data.Map.Internal.fromList
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (go13
                           (GHC.Types.[] @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a))
                           ww) of dt { DEFAULT ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a w
                 } in
                 case Data.Map.Strict.Internal.unionWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (GHC.Num.+ @ a $dNum)
                        ww
                        dt of dt1 { DEFAULT ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        (GHC.Num.*
                           @ a
                           $dNum
                           (GHC.Real./
                              @ a
                              w
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor2)
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor1)))
                        dt1 of dt2 { DEFAULT ->
                 (# dt2 #) } } }) -}
e148b193b35a118fd571875fb29a10c9
  $wcyclicSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> [GHC.Types.Int]
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 4,
     Strictness: <L,U(1*U(C(C1(U)),A,1*C1(C(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U(U)><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Types.Int])
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a w
                 } in
                 let {
                   lvl3 :: a = GHC.Num.fromInteger @ a $dNum Tensor.cyclicSymTensor1
                 } in
                 case Data.Map.Strict.Internal.mapWithKey
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        @ a
                        (\ (k :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8) (a1 :: a)[OneShot] ->
                         case w1 of ww1 { GHC.Types.I# ww2 ->
                         case k of ww3 { Index.Index ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                         letrec {
                           go :: [Index.Index n1 n2 n3 n4 n5 n6 n7 n8] -> a -> a
                             <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                           = \ (ds :: [Index.Index n1 n2 n3 n4 n5 n6 n7 n8]) (eta :: a) ->
                             case ds of wild {
                               [] -> eta
                               : y ys
                               -> go
                                    ys
                                    (GHC.Num.+
                                       @ a
                                       $dNum
                                       eta
                                       (Data.Map.Internal.find
                                          @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                                          @ a
                                          (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                                          y
                                          ww)) }
                         } in
                         go
                           (Index.$wcyclicSwapIndex
                              @ n1
                              @ n2
                              @ n3
                              @ n4
                              @ n5
                              @ n6
                              @ n7
                              @ n8
                              ww2
                              w2
                              ww4
                              ww5
                              ww6
                              ww7
                              ww8
                              ww9
                              ww10
                              ww11)
                           lvl3 } })
                        ww of dt { DEFAULT ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        (GHC.Num.*
                           @ a
                           $dNum
                           (GHC.Real./
                              @ a
                              w
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor2)
                              (GHC.Num.fromInteger
                                 @ a
                                 $dNum
                                 (case GHC.List.$wlenAcc @ GHC.Types.Int w2 0# of ww2 { DEFAULT ->
                                  case Tensor.$w$sfactorial ww2 of ww1 { DEFAULT ->
                                  GHC.Integer.Type.smallInteger ww1 } }))))
                        dt of dt1 { DEFAULT ->
                 (# dt1 #) } }) -}
928168666babbff062867cb39bbc7468
  $wgetVal ::
    GHC.Num.Num a =>
    Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a
  {- Arity: 3, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (w1 :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8) ->
                 case Data.Map.Internal.member
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w1
                        ww of wild {
                   GHC.Types.False
                   -> GHC.Num.fromInteger @ a w Tensor.cyclicSymTensor1
                   GHC.Types.True
                   -> Data.Map.Internal.find
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w1
                        ww }) -}
8e4a1b4739fde541b6715a70dfb57127
  $wsymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 4,
     Strictness: <L,U(1*U(1*C(C1(U)),A,1*C1(C(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U(U)><L,U(U(U),U(U))><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 case Tensor.$wtensorTranspose
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ a
                        w1
                        w2
                        ww of ww1 { Unit# ww2 ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a w
                 } in
                 case Data.Map.Strict.Internal.unionWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (GHC.Num.+ @ a $dNum)
                        ww
                        ww2 of dt { DEFAULT ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        (GHC.Num.*
                           @ a
                           $dNum
                           (GHC.Real./
                              @ a
                              w
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor2)
                              (GHC.Num.fromInteger @ a $dNum Tensor.aSymTensor1)))
                        dt of dt1 { DEFAULT ->
                 (# dt1 #) } } }) -}
6a0291f078511ab0b54ae66bbec44b38
  $wtensorContractWith_19 ::
    (GHC.TypeNats.KnownNat n3, GHC.TypeNats.KnownNat n4) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Data.Map.Internal.Map
         (Index.Index
            n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8)
         a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n3)
                   (w1 :: GHC.TypeNats.KnownNat n4)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index
                               n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8)
                            a) ->
                 case Data.Map.Strict.Internal.mapKeysWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        @ (Index.Index
                             n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8)
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w3
                        (Index.delContractionIndex_19
                           @ n3
                           @ n4
                           @ n1
                           @ n2
                           @ n5
                           @ n6
                           @ n7
                           @ n8
                           w
                           w1
                           w2)
                        (Data.Map.Internal.filterWithKey
                           @ (Index.Index
                                n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8)
                           @ a
                           (\ (k :: Index.Index
                                      n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8)
                              (ds :: a)[OneShot] ->
                            Index.isContractionIndex
                              @ n1
                              @ n2
                              @ (n3 GHC.TypeNats.+ 1)
                              @ (n4 GHC.TypeNats.+ 1)
                              @ n5
                              @ n6
                              @ n7
                              @ n8
                              Tensor.tensorContractWith_1
                              w2
                              k)
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
374a6074c3b61c3d8a8deb97deb76b82
  $wtensorContractWith_20 ::
    (GHC.TypeNats.KnownNat n1, GHC.TypeNats.KnownNat n2) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Data.Map.Internal.Map
         (Index.Index
            (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8)
         a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ a
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n1)
                   (w1 :: GHC.TypeNats.KnownNat n2)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index
                               (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8)
                            a) ->
                 case Data.Map.Strict.Internal.mapKeysWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        @ (Index.Index
                             (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8)
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w3
                        (Index.delContractionIndex_20
                           @ n1
                           @ n2
                           @ n3
                           @ n4
                           @ n5
                           @ n6
                           @ n7
                           @ n8
                           w
                           w1
                           w2)
                        (Data.Map.Internal.filterWithKey
                           @ (Index.Index
                                (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8)
                           @ a
                           (\ (k :: Index.Index
                                      (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8)
                              (ds :: a)[OneShot] ->
                            Index.isContractionIndex
                              @ (n1 GHC.TypeNats.+ 1)
                              @ (n2 GHC.TypeNats.+ 1)
                              @ n3
                              @ n4
                              @ n5
                              @ n6
                              @ n7
                              @ n8
                              Tensor.tensorContractWith_2
                              w2
                              k)
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
bf885610833d573dfd51936e84e8125a
  $wtensorContractWith_3 ::
    (GHC.TypeNats.KnownNat n7, GHC.TypeNats.KnownNat n8) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Data.Map.Internal.Map
         (Index.Index
            n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1))
         a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n7)
                   (w1 :: GHC.TypeNats.KnownNat n8)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index
                               n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1))
                            a) ->
                 case Data.Map.Strict.Internal.mapKeysWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        @ (Index.Index
                             n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1))
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w3
                        (Index.delContractionIndex_3
                           @ n7
                           @ n8
                           @ n1
                           @ n2
                           @ n3
                           @ n4
                           @ n5
                           @ n6
                           w
                           w1
                           w2)
                        (Data.Map.Internal.filterWithKey
                           @ (Index.Index
                                n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1))
                           @ a
                           (\ (k :: Index.Index
                                      n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1))
                              (ds :: a)[OneShot] ->
                            Index.isContractionIndex
                              @ n1
                              @ n2
                              @ n3
                              @ n4
                              @ n5
                              @ n6
                              @ (n7 GHC.TypeNats.+ 1)
                              @ (n8 GHC.TypeNats.+ 1)
                              Tensor.tensorContractWith_4
                              w2
                              k)
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
46f313ffd41149d740af22f64ef9fbe0
  $wtensorContractWith_9 ::
    (GHC.TypeNats.KnownNat n5, GHC.TypeNats.KnownNat n6) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Data.Map.Internal.Map
         (Index.Index
            n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8)
         a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n5)
                   (w1 :: GHC.TypeNats.KnownNat n6)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index
                               n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8)
                            a) ->
                 case Data.Map.Strict.Internal.mapKeysWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        @ (Index.Index
                             n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8)
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        w3
                        (Index.delContractionIndex_9
                           @ n5
                           @ n6
                           @ n1
                           @ n2
                           @ n3
                           @ n4
                           @ n7
                           @ n8
                           w
                           w1
                           w2)
                        (Data.Map.Internal.filterWithKey
                           @ (Index.Index
                                n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8)
                           @ a
                           (\ (k :: Index.Index
                                      n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8)
                              (ds :: a)[OneShot] ->
                            Index.isContractionIndex
                              @ n1
                              @ n2
                              @ n3
                              @ n4
                              @ (n5 GHC.TypeNats.+ 1)
                              @ (n6 GHC.TypeNats.+ 1)
                              @ n7
                              @ n8
                              Tensor.tensorContractWith_5
                              w2
                              k)
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
89ad660842f89ad9159142bd7639c393
  $wtensorProductNew ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) a
    -> (# Data.Map.Internal.Map
            (Index.Index
               (n1 GHC.TypeNats.+ m1)
               (n2 GHC.TypeNats.+ m2)
               (n3 GHC.TypeNats.+ m3)
               (n4 GHC.TypeNats.+ m4)
               (n5 GHC.TypeNats.+ m5)
               (n6 GHC.TypeNats.+ m6)
               (n7 GHC.TypeNats.+ m7)
               (n8 GHC.TypeNats.+ m8))
            a #)
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) a) ->
                 let {
                   xs :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]
                   = let {
                       ds :: a = GHC.Num.fromInteger @ a w Tensor.cyclicSymTensor1
                     } in
                     Data.Map.Internal.$fDataMap_go
                       @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                       @ a
                       (GHC.Types.[] @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a))
                       (Data.Map.Internal.filterWithKey
                          @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                          @ a
                          (\ (ds1 :: Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                             (x :: a)[OneShot] ->
                           GHC.Classes./= @ a w1 x ds)
                          ww1)
                 } in
                 letrec {
                   go13 :: [(Index.Index
                               (n1 GHC.TypeNats.+ m1)
                               (n2 GHC.TypeNats.+ m2)
                               (n3 GHC.TypeNats.+ m3)
                               (n4 GHC.TypeNats.+ m4)
                               (n5 GHC.TypeNats.+ m5)
                               (n6 GHC.TypeNats.+ m6)
                               (n7 GHC.TypeNats.+ m7)
                               (n8 GHC.TypeNats.+ m8),
                             a)]
                           -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                           -> [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                a)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                a)])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (let {
                               ds1 :: [(Index.Index
                                          (n1 GHC.TypeNats.+ m1)
                                          (n2 GHC.TypeNats.+ m2)
                                          (n3 GHC.TypeNats.+ m3)
                                          (n4 GHC.TypeNats.+ m4)
                                          (n5 GHC.TypeNats.+ m5)
                                          (n6 GHC.TypeNats.+ m6)
                                          (n7 GHC.TypeNats.+ m7)
                                          (n8 GHC.TypeNats.+ m8),
                                        a)]
                               = go13 z' r
                             } in
                             letrec {
                               go :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]
                                     -> [(Index.Index
                                            (n1 GHC.TypeNats.+ m1)
                                            (n2 GHC.TypeNats.+ m2)
                                            (n3 GHC.TypeNats.+ m3)
                                            (n4 GHC.TypeNats.+ m4)
                                            (n5 GHC.TypeNats.+ m5)
                                            (n6 GHC.TypeNats.+ m6)
                                            (n7 GHC.TypeNats.+ m7)
                                            (n8 GHC.TypeNats.+ m8),
                                          a)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds2 :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]) ->
                                 case ds2 of wild1 {
                                   [] -> ds1
                                   : y ys
                                   -> GHC.Types.:
                                        @ (Index.Index
                                             (n1 GHC.TypeNats.+ m1)
                                             (n2 GHC.TypeNats.+ m2)
                                             (n3 GHC.TypeNats.+ m3)
                                             (n4 GHC.TypeNats.+ m4)
                                             (n5 GHC.TypeNats.+ m5)
                                             (n6 GHC.TypeNats.+ m6)
                                             (n7 GHC.TypeNats.+ m7)
                                             (n8 GHC.TypeNats.+ m8),
                                           a)
                                        (case y of wild2 { (,) ind2 val2 ->
                                         (Index.combineIndex
                                            @ n1
                                            @ n2
                                            @ n3
                                            @ n4
                                            @ n5
                                            @ n6
                                            @ n7
                                            @ n8
                                            @ m1
                                            @ m2
                                            @ m3
                                            @ m4
                                            @ m5
                                            @ m6
                                            @ m7
                                            @ m8
                                            kx
                                            ind2,
                                          GHC.Num.* @ a w x val2) })
                                        (go ys) }
                             } in
                             go xs)
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 let {
                   ds :: a = GHC.Num.fromInteger @ a w Tensor.cyclicSymTensor1
                 } in
                 case Data.Map.Strict.Internal.fromList
                        @ (Index.Index
                             (n1 GHC.TypeNats.+ m1)
                             (n2 GHC.TypeNats.+ m2)
                             (n3 GHC.TypeNats.+ m3)
                             (n4 GHC.TypeNats.+ m4)
                             (n5 GHC.TypeNats.+ m5)
                             (n6 GHC.TypeNats.+ m6)
                             (n7 GHC.TypeNats.+ m7)
                             (n8 GHC.TypeNats.+ m8))
                        @ a
                        (Index.$fOrdIndex
                           @ (n1 GHC.TypeNats.+ m1)
                           @ (n2 GHC.TypeNats.+ m2)
                           @ (n3 GHC.TypeNats.+ m3)
                           @ (n4 GHC.TypeNats.+ m4)
                           @ (n5 GHC.TypeNats.+ m5)
                           @ (n6 GHC.TypeNats.+ m6)
                           @ (n7 GHC.TypeNats.+ m7)
                           @ (n8 GHC.TypeNats.+ m8))
                        (go13
                           (GHC.Types.[]
                              @ (Index.Index
                                   (n1 GHC.TypeNats.+ m1)
                                   (n2 GHC.TypeNats.+ m2)
                                   (n3 GHC.TypeNats.+ m3)
                                   (n4 GHC.TypeNats.+ m4)
                                   (n5 GHC.TypeNats.+ m5)
                                   (n6 GHC.TypeNats.+ m6)
                                   (n7 GHC.TypeNats.+ m7)
                                   (n8 GHC.TypeNats.+ m8),
                                 a))
                           (Data.Map.Internal.filterWithKey
                              @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                              @ a
                              (\ (ds1 :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                                 (x :: a)[OneShot] ->
                               GHC.Classes./= @ a w1 x ds)
                              ww)) of dt { DEFAULT ->
                 (# dt #) }) -}
7e34bd4181966d160316a6a758f99f4e
  $wtensorProductNumeric ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) a
    -> (# Data.Map.Internal.Map
            (Index.Index
               (n1 GHC.TypeNats.+ m1)
               (n2 GHC.TypeNats.+ m2)
               (n3 GHC.TypeNats.+ m3)
               (n4 GHC.TypeNats.+ m4)
               (n5 GHC.TypeNats.+ m5)
               (n6 GHC.TypeNats.+ m6)
               (n7 GHC.TypeNats.+ m7)
               (n8 GHC.TypeNats.+ m8))
            a #)
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) a) ->
                 let {
                   xs :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]
                   = let {
                       ds :: a = GHC.Num.fromInteger @ a w Tensor.cyclicSymTensor1
                     } in
                     Data.Map.Internal.$fDataMap_go
                       @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                       @ a
                       (GHC.Types.[] @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a))
                       (Data.Map.Internal.filterWithKey
                          @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                          @ a
                          (\ (ds1 :: Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                             (x :: a)[OneShot] ->
                           GHC.Classes./= @ a w1 x ds)
                          ww1)
                 } in
                 letrec {
                   go13 :: [(Index.Index
                               (n1 GHC.TypeNats.+ m1)
                               (n2 GHC.TypeNats.+ m2)
                               (n3 GHC.TypeNats.+ m3)
                               (n4 GHC.TypeNats.+ m4)
                               (n5 GHC.TypeNats.+ m5)
                               (n6 GHC.TypeNats.+ m6)
                               (n7 GHC.TypeNats.+ m7)
                               (n8 GHC.TypeNats.+ m8),
                             a)]
                           -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                           -> [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                a)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                a)])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (let {
                               ds1 :: [(Index.Index
                                          (n1 GHC.TypeNats.+ m1)
                                          (n2 GHC.TypeNats.+ m2)
                                          (n3 GHC.TypeNats.+ m3)
                                          (n4 GHC.TypeNats.+ m4)
                                          (n5 GHC.TypeNats.+ m5)
                                          (n6 GHC.TypeNats.+ m6)
                                          (n7 GHC.TypeNats.+ m7)
                                          (n8 GHC.TypeNats.+ m8),
                                        a)]
                               = go13 z' r
                             } in
                             letrec {
                               go :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]
                                     -> [(Index.Index
                                            (n1 GHC.TypeNats.+ m1)
                                            (n2 GHC.TypeNats.+ m2)
                                            (n3 GHC.TypeNats.+ m3)
                                            (n4 GHC.TypeNats.+ m4)
                                            (n5 GHC.TypeNats.+ m5)
                                            (n6 GHC.TypeNats.+ m6)
                                            (n7 GHC.TypeNats.+ m7)
                                            (n8 GHC.TypeNats.+ m8),
                                          a)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds2 :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, a)]) ->
                                 case ds2 of wild1 {
                                   [] -> ds1
                                   : y ys
                                   -> GHC.Types.:
                                        @ (Index.Index
                                             (n1 GHC.TypeNats.+ m1)
                                             (n2 GHC.TypeNats.+ m2)
                                             (n3 GHC.TypeNats.+ m3)
                                             (n4 GHC.TypeNats.+ m4)
                                             (n5 GHC.TypeNats.+ m5)
                                             (n6 GHC.TypeNats.+ m6)
                                             (n7 GHC.TypeNats.+ m7)
                                             (n8 GHC.TypeNats.+ m8),
                                           a)
                                        (case y of wild2 { (,) c d ->
                                         (Index.combineIndex
                                            @ n1
                                            @ n2
                                            @ n3
                                            @ n4
                                            @ n5
                                            @ n6
                                            @ n7
                                            @ n8
                                            @ m1
                                            @ m2
                                            @ m3
                                            @ m4
                                            @ m5
                                            @ m6
                                            @ m7
                                            @ m8
                                            kx
                                            c,
                                          GHC.Num.* @ a w x d) })
                                        (go ys) }
                             } in
                             go xs)
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 let {
                   ds :: a = GHC.Num.fromInteger @ a w Tensor.cyclicSymTensor1
                 } in
                 case Data.Map.Strict.Internal.fromAscListWithKey
                        @ (Index.Index
                             (n1 GHC.TypeNats.+ m1)
                             (n2 GHC.TypeNats.+ m2)
                             (n3 GHC.TypeNats.+ m3)
                             (n4 GHC.TypeNats.+ m4)
                             (n5 GHC.TypeNats.+ m5)
                             (n6 GHC.TypeNats.+ m6)
                             (n7 GHC.TypeNats.+ m7)
                             (n8 GHC.TypeNats.+ m8))
                        @ a
                        (Index.$fEqIndex
                           @ (n1 GHC.TypeNats.+ m1)
                           @ (n2 GHC.TypeNats.+ m2)
                           @ (n3 GHC.TypeNats.+ m3)
                           @ (n4 GHC.TypeNats.+ m4)
                           @ (n5 GHC.TypeNats.+ m5)
                           @ (n6 GHC.TypeNats.+ m6)
                           @ (n7 GHC.TypeNats.+ m7)
                           @ (n8 GHC.TypeNats.+ m8))
                        (Tensor.tensorProductNumeric1
                           @ n1
                           @ m1
                           @ n2
                           @ m2
                           @ n3
                           @ m3
                           @ n4
                           @ m4
                           @ n5
                           @ m5
                           @ n6
                           @ m6
                           @ n7
                           @ m7
                           @ n8
                           @ m8
                           @ a)
                        (go13
                           (GHC.Types.[]
                              @ (Index.Index
                                   (n1 GHC.TypeNats.+ m1)
                                   (n2 GHC.TypeNats.+ m2)
                                   (n3 GHC.TypeNats.+ m3)
                                   (n4 GHC.TypeNats.+ m4)
                                   (n5 GHC.TypeNats.+ m5)
                                   (n6 GHC.TypeNats.+ m6)
                                   (n7 GHC.TypeNats.+ m7)
                                   (n8 GHC.TypeNats.+ m8),
                                 a))
                           (Data.Map.Internal.filterWithKey
                              @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                              @ a
                              (\ (ds1 :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                                 (x :: a)[OneShot] ->
                               GHC.Classes./= @ a w1 x ds)
                              ww)) of dt { DEFAULT ->
                 (# dt #) }) -}
bd8ac78670e5685d4b64986acbfae993
  $wtensorProductNumeric2 ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) a
    -> (# Data.Map.Internal.Map
            (Index.Index
               (n1 GHC.TypeNats.+ m1)
               (n2 GHC.TypeNats.+ m2)
               (n3 GHC.TypeNats.+ m3)
               (n4 GHC.TypeNats.+ m4)
               (n5 GHC.TypeNats.+ m5)
               (n6 GHC.TypeNats.+ m6)
               (n7 GHC.TypeNats.+ m7)
               (n8 GHC.TypeNats.+ m8))
            a #)
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><L,1*U><S,1*U>,
     Inline: [0] -}
53d67238c3cf4a3381f41968f3b585e1
  $wtensorProductWith ::
    (a -> b -> c)
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b
    -> (# Data.Map.Internal.Map
            (Index.Index
               (n1 GHC.TypeNats.+ m1)
               (n2 GHC.TypeNats.+ m2)
               (n3 GHC.TypeNats.+ m3)
               (n4 GHC.TypeNats.+ m4)
               (n5 GHC.TypeNats.+ m5)
               (n6 GHC.TypeNats.+ m6)
               (n7 GHC.TypeNats.+ m7)
               (n8 GHC.TypeNats.+ m8))
            c #)
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: a -> b -> c)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b) ->
                 let {
                   xs :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, b)]
                   = Data.Map.Internal.$fDataMap_go
                       @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                       @ b
                       (GHC.Types.[] @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8, b))
                       ww1
                 } in
                 letrec {
                   go13 :: [(Index.Index
                               (n1 GHC.TypeNats.+ m1)
                               (n2 GHC.TypeNats.+ m2)
                               (n3 GHC.TypeNats.+ m3)
                               (n4 GHC.TypeNats.+ m4)
                               (n5 GHC.TypeNats.+ m5)
                               (n6 GHC.TypeNats.+ m6)
                               (n7 GHC.TypeNats.+ m7)
                               (n8 GHC.TypeNats.+ m8),
                             c)]
                           -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                           -> [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                c)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(Index.Index
                                  (n1 GHC.TypeNats.+ m1)
                                  (n2 GHC.TypeNats.+ m2)
                                  (n3 GHC.TypeNats.+ m3)
                                  (n4 GHC.TypeNats.+ m4)
                                  (n5 GHC.TypeNats.+ m5)
                                  (n6 GHC.TypeNats.+ m6)
                                  (n7 GHC.TypeNats.+ m7)
                                  (n8 GHC.TypeNats.+ m8),
                                c)])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (let {
                               ds1 :: [(Index.Index
                                          (n1 GHC.TypeNats.+ m1)
                                          (n2 GHC.TypeNats.+ m2)
                                          (n3 GHC.TypeNats.+ m3)
                                          (n4 GHC.TypeNats.+ m4)
                                          (n5 GHC.TypeNats.+ m5)
                                          (n6 GHC.TypeNats.+ m6)
                                          (n7 GHC.TypeNats.+ m7)
                                          (n8 GHC.TypeNats.+ m8),
                                        c)]
                               = go13 z' r
                             } in
                             letrec {
                               go :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, b)]
                                     -> [(Index.Index
                                            (n1 GHC.TypeNats.+ m1)
                                            (n2 GHC.TypeNats.+ m2)
                                            (n3 GHC.TypeNats.+ m3)
                                            (n4 GHC.TypeNats.+ m4)
                                            (n5 GHC.TypeNats.+ m5)
                                            (n6 GHC.TypeNats.+ m6)
                                            (n7 GHC.TypeNats.+ m7)
                                            (n8 GHC.TypeNats.+ m8),
                                          c)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds2 :: [(Index.Index m1 m2 m3 m4 m5 m6 m7 m8, b)]) ->
                                 case ds2 of wild1 {
                                   [] -> ds1
                                   : y ys
                                   -> GHC.Types.:
                                        @ (Index.Index
                                             (n1 GHC.TypeNats.+ m1)
                                             (n2 GHC.TypeNats.+ m2)
                                             (n3 GHC.TypeNats.+ m3)
                                             (n4 GHC.TypeNats.+ m4)
                                             (n5 GHC.TypeNats.+ m5)
                                             (n6 GHC.TypeNats.+ m6)
                                             (n7 GHC.TypeNats.+ m7)
                                             (n8 GHC.TypeNats.+ m8),
                                           c)
                                        (case y of wild2 { (,) c1 d ->
                                         (Index.combineIndex
                                            @ n1
                                            @ n2
                                            @ n3
                                            @ n4
                                            @ n5
                                            @ n6
                                            @ n7
                                            @ n8
                                            @ m1
                                            @ m2
                                            @ m3
                                            @ m4
                                            @ m5
                                            @ m6
                                            @ m7
                                            @ m8
                                            kx
                                            c1,
                                          w x d) })
                                        (go ys) }
                             } in
                             go xs)
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 case Data.Map.Strict.Internal.fromAscListWithKey
                        @ (Index.Index
                             (n1 GHC.TypeNats.+ m1)
                             (n2 GHC.TypeNats.+ m2)
                             (n3 GHC.TypeNats.+ m3)
                             (n4 GHC.TypeNats.+ m4)
                             (n5 GHC.TypeNats.+ m5)
                             (n6 GHC.TypeNats.+ m6)
                             (n7 GHC.TypeNats.+ m7)
                             (n8 GHC.TypeNats.+ m8))
                        @ c
                        (Index.$fEqIndex
                           @ (n1 GHC.TypeNats.+ m1)
                           @ (n2 GHC.TypeNats.+ m2)
                           @ (n3 GHC.TypeNats.+ m3)
                           @ (n4 GHC.TypeNats.+ m4)
                           @ (n5 GHC.TypeNats.+ m5)
                           @ (n6 GHC.TypeNats.+ m6)
                           @ (n7 GHC.TypeNats.+ m7)
                           @ (n8 GHC.TypeNats.+ m8))
                        (Tensor.tensorProductNumeric1
                           @ n1
                           @ m1
                           @ n2
                           @ m2
                           @ n3
                           @ m3
                           @ n4
                           @ m4
                           @ n5
                           @ m5
                           @ n6
                           @ m6
                           @ n7
                           @ m7
                           @ n8
                           @ m8
                           @ c)
                        (go13
                           (GHC.Types.[]
                              @ (Index.Index
                                   (n1 GHC.TypeNats.+ m1)
                                   (n2 GHC.TypeNats.+ m2)
                                   (n3 GHC.TypeNats.+ m3)
                                   (n4 GHC.TypeNats.+ m4)
                                   (n5 GHC.TypeNats.+ m5)
                                   (n6 GHC.TypeNats.+ m6)
                                   (n7 GHC.TypeNats.+ m7)
                                   (n8 GHC.TypeNats.+ m8),
                                 c))
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
7165731836fd681d8cd48f3d77430140
  $wtensorProductWith2 ::
    (a -> b -> c)
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b
    -> (# Data.Map.Internal.Map
            (Index.Index
               (n1 GHC.TypeNats.+ m1)
               (n2 GHC.TypeNats.+ m2)
               (n3 GHC.TypeNats.+ m3)
               (n4 GHC.TypeNats.+ m4)
               (n5 GHC.TypeNats.+ m5)
               (n6 GHC.TypeNats.+ m6)
               (n7 GHC.TypeNats.+ m7)
               (n8 GHC.TypeNats.+ m8))
            c #)
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: a -> b -> c)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b) ->
                 letrec {
                   go13 :: [Data.Map.Internal.Map
                              (Index.Index
                                 (n1 GHC.TypeNats.+ m1)
                                 (n2 GHC.TypeNats.+ m2)
                                 (n3 GHC.TypeNats.+ m3)
                                 (n4 GHC.TypeNats.+ m4)
                                 (n5 GHC.TypeNats.+ m5)
                                 (n6 GHC.TypeNats.+ m6)
                                 (n7 GHC.TypeNats.+ m7)
                                 (n8 GHC.TypeNats.+ m8))
                              c]
                           -> Data.Map.Internal.Map (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b
                           -> [Data.Map.Internal.Map
                                 (Index.Index
                                    (n1 GHC.TypeNats.+ m1)
                                    (n2 GHC.TypeNats.+ m2)
                                    (n3 GHC.TypeNats.+ m3)
                                    (n4 GHC.TypeNats.+ m4)
                                    (n5 GHC.TypeNats.+ m5)
                                    (n6 GHC.TypeNats.+ m6)
                                    (n7 GHC.TypeNats.+ m7)
                                    (n8 GHC.TypeNats.+ m8))
                                 c]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [Data.Map.Internal.Map
                                 (Index.Index
                                    (n1 GHC.TypeNats.+ m1)
                                    (n2 GHC.TypeNats.+ m2)
                                    (n3 GHC.TypeNats.+ m3)
                                    (n4 GHC.TypeNats.+ m4)
                                    (n5 GHC.TypeNats.+ m5)
                                    (n6 GHC.TypeNats.+ m6)
                                    (n7 GHC.TypeNats.+ m7)
                                    (n8 GHC.TypeNats.+ m8))
                                 c])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index m1 m2 m3 m4 m5 m6 m7 m8) b) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (GHC.Types.:
                               @ (Data.Map.Internal.Map
                                    (Index.Index
                                       (n1 GHC.TypeNats.+ m1)
                                       (n2 GHC.TypeNats.+ m2)
                                       (n3 GHC.TypeNats.+ m3)
                                       (n4 GHC.TypeNats.+ m4)
                                       (n5 GHC.TypeNats.+ m5)
                                       (n6 GHC.TypeNats.+ m6)
                                       (n7 GHC.TypeNats.+ m7)
                                       (n8 GHC.TypeNats.+ m8))
                                    c)
                               (let {
                                  val :: b
                                  = Data.Map.Internal.find
                                      @ (Index.Index m1 m2 m3 m4 m5 m6 m7 m8)
                                      @ b
                                      (Index.$fOrdIndex @ m1 @ m2 @ m3 @ m4 @ m5 @ m6 @ m7 @ m8)
                                      kx
                                      ww1
                                } in
                                letrec {
                                  go8 :: Data.Map.Internal.Map
                                           (Index.Index
                                              (n1 GHC.TypeNats.+ m1)
                                              (n2 GHC.TypeNats.+ m2)
                                              (n3 GHC.TypeNats.+ m3)
                                              (n4 GHC.TypeNats.+ m4)
                                              (n5 GHC.TypeNats.+ m5)
                                              (n6 GHC.TypeNats.+ m6)
                                              (n7 GHC.TypeNats.+ m7)
                                              (n8 GHC.TypeNats.+ m8))
                                           a
                                         -> Data.Map.Internal.Map
                                              (Index.Index
                                                 (n1 GHC.TypeNats.+ m1)
                                                 (n2 GHC.TypeNats.+ m2)
                                                 (n3 GHC.TypeNats.+ m3)
                                                 (n4 GHC.TypeNats.+ m4)
                                                 (n5 GHC.TypeNats.+ m5)
                                                 (n6 GHC.TypeNats.+ m6)
                                                 (n7 GHC.TypeNats.+ m7)
                                                 (n8 GHC.TypeNats.+ m8))
                                              c
                                    {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ (ds1 :: Data.Map.Internal.Map
                                                (Index.Index
                                                   (n1 GHC.TypeNats.+ m1)
                                                   (n2 GHC.TypeNats.+ m2)
                                                   (n3 GHC.TypeNats.+ m3)
                                                   (n4 GHC.TypeNats.+ m4)
                                                   (n5 GHC.TypeNats.+ m5)
                                                   (n6 GHC.TypeNats.+ m6)
                                                   (n7 GHC.TypeNats.+ m7)
                                                   (n8 GHC.TypeNats.+ m8))
                                                a) ->
                                    case ds1 of wild1 {
                                      Data.Map.Internal.Bin dt1 kx1 x1 l1 r1
                                      -> case w x1 val of x' { DEFAULT ->
                                         case go8 l1 of dt2 { DEFAULT ->
                                         case go8 r1 of dt3 { DEFAULT ->
                                         Data.Map.Internal.Bin
                                           @ (Index.Index
                                                (n1 GHC.TypeNats.+ m1)
                                                (n2 GHC.TypeNats.+ m2)
                                                (n3 GHC.TypeNats.+ m3)
                                                (n4 GHC.TypeNats.+ m4)
                                                (n5 GHC.TypeNats.+ m5)
                                                (n6 GHC.TypeNats.+ m6)
                                                (n7 GHC.TypeNats.+ m7)
                                                (n8 GHC.TypeNats.+ m8))
                                           @ c
                                           dt1
                                           kx1
                                           x'
                                           dt2
                                           dt3 } } }
                                      Data.Map.Internal.Tip
                                      -> Data.Map.Internal.Tip
                                           @ (Index.Index
                                                (n1 GHC.TypeNats.+ m1)
                                                (n2 GHC.TypeNats.+ m2)
                                                (n3 GHC.TypeNats.+ m3)
                                                (n4 GHC.TypeNats.+ m4)
                                                (n5 GHC.TypeNats.+ m5)
                                                (n6 GHC.TypeNats.+ m6)
                                                (n7 GHC.TypeNats.+ m7)
                                                (n8 GHC.TypeNats.+ m8))
                                           @ c }
                                } in
                                letrec {
                                  go1 :: [(Index.Index
                                             (n1 GHC.TypeNats.+ m1)
                                             (n2 GHC.TypeNats.+ m2)
                                             (n3 GHC.TypeNats.+ m3)
                                             (n4 GHC.TypeNats.+ m4)
                                             (n5 GHC.TypeNats.+ m5)
                                             (n6 GHC.TypeNats.+ m6)
                                             (n7 GHC.TypeNats.+ m7)
                                             (n8 GHC.TypeNats.+ m8),
                                           a)]
                                         -> Data.Map.Internal.Map
                                              (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                                         -> [(Index.Index
                                                (n1 GHC.TypeNats.+ m1)
                                                (n2 GHC.TypeNats.+ m2)
                                                (n3 GHC.TypeNats.+ m3)
                                                (n4 GHC.TypeNats.+ m4)
                                                (n5 GHC.TypeNats.+ m5)
                                                (n6 GHC.TypeNats.+ m6)
                                                (n7 GHC.TypeNats.+ m7)
                                                (n8 GHC.TypeNats.+ m8),
                                              a)]
                                    {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                                  = \ (z'1 :: [(Index.Index
                                                  (n1 GHC.TypeNats.+ m1)
                                                  (n2 GHC.TypeNats.+ m2)
                                                  (n3 GHC.TypeNats.+ m3)
                                                  (n4 GHC.TypeNats.+ m4)
                                                  (n5 GHC.TypeNats.+ m5)
                                                  (n6 GHC.TypeNats.+ m6)
                                                  (n7 GHC.TypeNats.+ m7)
                                                  (n8 GHC.TypeNats.+ m8),
                                                a)])
                                      (ds1 :: Data.Map.Internal.Map
                                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                                    case ds1 of wild1 {
                                      Data.Map.Internal.Bin dt1 kx1 x1 l1 r1
                                      -> go1
                                           (GHC.Types.:
                                              @ (Index.Index
                                                   (n1 GHC.TypeNats.+ m1)
                                                   (n2 GHC.TypeNats.+ m2)
                                                   (n3 GHC.TypeNats.+ m3)
                                                   (n4 GHC.TypeNats.+ m4)
                                                   (n5 GHC.TypeNats.+ m5)
                                                   (n6 GHC.TypeNats.+ m6)
                                                   (n7 GHC.TypeNats.+ m7)
                                                   (n8 GHC.TypeNats.+ m8),
                                                 a)
                                              (Index.combineIndex
                                                 @ n1
                                                 @ n2
                                                 @ n3
                                                 @ n4
                                                 @ n5
                                                 @ n6
                                                 @ n7
                                                 @ n8
                                                 @ m1
                                                 @ m2
                                                 @ m3
                                                 @ m4
                                                 @ m5
                                                 @ m6
                                                 @ m7
                                                 @ m8
                                                 kx1
                                                 kx,
                                               x1)
                                              (go1 z'1 r1))
                                           l1
                                      Data.Map.Internal.Tip -> z'1 }
                                } in
                                go8
                                  (Data.Map.Internal.fromList
                                     @ (Index.Index
                                          (n1 GHC.TypeNats.+ m1)
                                          (n2 GHC.TypeNats.+ m2)
                                          (n3 GHC.TypeNats.+ m3)
                                          (n4 GHC.TypeNats.+ m4)
                                          (n5 GHC.TypeNats.+ m5)
                                          (n6 GHC.TypeNats.+ m6)
                                          (n7 GHC.TypeNats.+ m7)
                                          (n8 GHC.TypeNats.+ m8))
                                     @ a
                                     (Index.$fOrdIndex
                                        @ (n1 GHC.TypeNats.+ m1)
                                        @ (n2 GHC.TypeNats.+ m2)
                                        @ (n3 GHC.TypeNats.+ m3)
                                        @ (n4 GHC.TypeNats.+ m4)
                                        @ (n5 GHC.TypeNats.+ m5)
                                        @ (n6 GHC.TypeNats.+ m6)
                                        @ (n7 GHC.TypeNats.+ m7)
                                        @ (n8 GHC.TypeNats.+ m8))
                                     (go1
                                        (GHC.Types.[]
                                           @ (Index.Index
                                                (n1 GHC.TypeNats.+ m1)
                                                (n2 GHC.TypeNats.+ m2)
                                                (n3 GHC.TypeNats.+ m3)
                                                (n4 GHC.TypeNats.+ m4)
                                                (n5 GHC.TypeNats.+ m5)
                                                (n6 GHC.TypeNats.+ m6)
                                                (n7 GHC.TypeNats.+ m7)
                                                (n8 GHC.TypeNats.+ m8),
                                              a))
                                        ww)))
                               (go13 z' r))
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 case Tensor.tensorProductWith1
                        @ n1
                        @ m1
                        @ n2
                        @ m2
                        @ n3
                        @ m3
                        @ n4
                        @ m4
                        @ n5
                        @ m5
                        @ n6
                        @ m6
                        @ n7
                        @ m7
                        @ n8
                        @ m8
                        @ c
                        (Data.Map.Internal.Tip
                           @ (Index.Index
                                (n1 GHC.TypeNats.+ m1)
                                (n2 GHC.TypeNats.+ m2)
                                (n3 GHC.TypeNats.+ m3)
                                (n4 GHC.TypeNats.+ m4)
                                (n5 GHC.TypeNats.+ m5)
                                (n6 GHC.TypeNats.+ m6)
                                (n7 GHC.TypeNats.+ m7)
                                (n8 GHC.TypeNats.+ m8))
                           @ c)
                        (go13
                           (GHC.Types.[]
                              @ (Data.Map.Internal.Map
                                   (Index.Index
                                      (n1 GHC.TypeNats.+ m1)
                                      (n2 GHC.TypeNats.+ m2)
                                      (n3 GHC.TypeNats.+ m3)
                                      (n4 GHC.TypeNats.+ m4)
                                      (n5 GHC.TypeNats.+ m5)
                                      (n6 GHC.TypeNats.+ m6)
                                      (n7 GHC.TypeNats.+ m7)
                                      (n8 GHC.TypeNats.+ m8))
                                   c))
                           ww1) of dt { DEFAULT ->
                 (# dt #) }) -}
302c14ca41740a6a331e4e2a8504f025
  $wtensorSub ::
    GHC.Num.Num a =>
    Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 3,
     Strictness: <L,U(1*C(C1(U)),A,1*C1(C(U)),1*C1(U),A,A,1*C1(U))><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
                   (ww1 :: Data.Map.Internal.Map
                             (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        (GHC.Num.*
                           @ a
                           w
                           (GHC.Num.negate
                              @ a
                              w
                              (GHC.Num.fromInteger @ a w Tensor.aSymTensor2)))
                        ww1 of dt { DEFAULT ->
                 case Data.Map.Strict.Internal.unionWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (GHC.Num.+ @ a w)
                        ww
                        dt of dt1 { DEFAULT ->
                 (# dt1 #) } }) -}
2d915a80e3f33438041b9dd98018fbc7
  $wtensorTranspose ::
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
    -> (# Data.Map.Internal.Map
            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a #)
  {- Arity: 3, Strictness: <L,U(U)><L,U(U(U),U(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (w :: GHC.Types.Int)
                   (w1 :: (GHC.Types.Int, GHC.Types.Int))
                   (ww :: Data.Map.Internal.Map
                            (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                 letrec {
                   go13 :: [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
                           -> Data.Map.Internal.Map (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a
                           -> [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)])
                       (ds :: Data.Map.Internal.Map
                                (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (GHC.Types.:
                               @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)
                               (Index.swapPosIndex
                                  @ n1
                                  @ n2
                                  @ n3
                                  @ n4
                                  @ n5
                                  @ n6
                                  @ n7
                                  @ n8
                                  w
                                  w1
                                  kx,
                                x)
                               (go13 z' r))
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 case Data.Map.Internal.fromList
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (go13
                           (GHC.Types.[] @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a))
                           ww) of dt { DEFAULT ->
                 (# dt #) }) -}
3907440065a4b5e56c282f0fba1005c5
  type Rank =
    (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int, GHC.Types.Int,
     GHC.Types.Int, GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
6ebce5ff137d1d5d966e303383d35759
  type role Tensor nominal nominal nominal nominal nominal nominal nominal nominal representational
  data Tensor (n1 :: GHC.Types.Nat)
              (n2 :: GHC.Types.Nat)
              (n3 :: GHC.Types.Nat)
              (n4 :: GHC.Types.Nat)
              (n5 :: GHC.Types.Nat)
              (n6 :: GHC.Types.Nat)
              (n7 :: GHC.Types.Nat)
              (n8 :: GHC.Types.Nat)
              a
    = Tensor !(Data.Map.Internal.Map
                 (Index.Index n1 n2 n3 n4 n5 n6 n7 n8) a)
6aca1dcee6425e265e5076d9f3f4bdc2
  aSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A,C(C(U)),C(U),A,A,C(U)),C(C1(U)),A,A)><L,U(U)><L,U(U(U),U(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w3 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$waSymTensor
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
583b6c7a910309ce224966b7f1b018ea
  aSymTensor1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
66a203de9553546e7e419558a68189fc
  aSymTensor2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
011441a1a69476437e80100585974b30
  blockSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> ([GHC.Types.Int], [GHC.Types.Int])
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A,C(C(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U)><L,U(U,U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: ([GHC.Types.Int], [GHC.Types.Int]))
                   (w3 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w3 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wblockSymTensor
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
50df4f2b029c75fe9f6a503c05037d45
  cyclicSymTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> [GHC.Types.Int]
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A,C(C(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U)><L,U><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Types.Int])
                   (w3 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w3 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wcyclicSymTensor
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
292c410335a6ffc464f1056e5ce9d82a
  cyclicSymTensor1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
102b462a217587292416866578ccc21f
  evalFullTensor ::
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (ds :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case ds of wild { Tensor.Tensor m ->
                 Data.Map.Internal.$fDataMap_go
                   @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                   @ a
                   (GHC.Types.[] @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a))
                   m }) -}
efeee921ffe68ebe32d97dfeb2bdee4b
  evalTensorVals :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (ds :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case ds of wild { Tensor.Tensor m ->
                 Data.Map.Internal.elems_go
                   @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                   @ a
                   (GHC.Types.[] @ a)
                   m }) -}
c33d42ecfb15c9143b07c5d447d954ba
  getVal ::
    GHC.Num.Num a =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w2 :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 Tensor.$wgetVal
                   @ a
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   w
                   ww1
                   w2 }) -}
ba590197a14d1eb55c47d57b36a79746
  mkTensorfromF ::
    (GHC.TypeNats.KnownNat n1, GHC.TypeNats.KnownNat n2,
     GHC.TypeNats.KnownNat n3, GHC.TypeNats.KnownNat n4,
     GHC.TypeNats.KnownNat n5, GHC.TypeNats.KnownNat n6,
     GHC.TypeNats.KnownNat n7, GHC.TypeNats.KnownNat n8, GHC.Num.Num a,
     GHC.Classes.Eq a) =>
    Tensor.Rank
    -> (Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 12,
     Strictness: <L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U(A,C(C1(U)))><S(S(S)LLLLLLL),1*U(1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U))><L,C(U)>m,
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dKnownNat :: GHC.TypeNats.KnownNat n1)
                   ($dKnownNat1 :: GHC.TypeNats.KnownNat n2)
                   ($dKnownNat2 :: GHC.TypeNats.KnownNat n3)
                   ($dKnownNat3 :: GHC.TypeNats.KnownNat n4)
                   ($dKnownNat4 :: GHC.TypeNats.KnownNat n5)
                   ($dKnownNat5 :: GHC.TypeNats.KnownNat n6)
                   ($dKnownNat6 :: GHC.TypeNats.KnownNat n7)
                   ($dKnownNat7 :: GHC.TypeNats.KnownNat n8)
                   ($dNum :: GHC.Num.Num a)
                   ($dEq :: GHC.Classes.Eq a)
                   (rank :: Tensor.Rank)
                   (f :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a) ->
                 let {
                   ds :: a = GHC.Num.fromInteger @ a $dNum Tensor.cyclicSymTensor1
                 } in
                 let {
                   indList :: [Index.Index n1 n2 n3 n4 n5 n6 n7 n8]
                   = Tensor.tensorIndList
                       @ n1
                       @ n2
                       @ n3
                       @ n4
                       @ n5
                       @ n6
                       @ n7
                       @ n8
                       $dKnownNat
                       $dKnownNat1
                       $dKnownNat2
                       $dKnownNat3
                       $dKnownNat4
                       $dKnownNat5
                       $dKnownNat6
                       $dKnownNat7
                       rank
                 } in
                 case Data.Map.Internal.filterWithKey
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (\ (ds1 :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                           (x :: a)[OneShot] ->
                         GHC.Classes./= @ a $dEq x ds)
                        (Data.Map.Strict.Internal.fromList
                           @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                           @ a
                           (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                           (GHC.List.zip
                              @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                              @ a
                              indList
                              (GHC.Base.map
                                 @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                                 @ a
                                 f
                                 indList))) of dt { DEFAULT ->
                 Tensor.Tensor @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8 @ a dt }) -}
8bbfd93fd03c55396eadcb0504f1acd6
  mkTensorfromFZeros ::
    (GHC.TypeNats.KnownNat n1, GHC.TypeNats.KnownNat n2,
     GHC.TypeNats.KnownNat n3, GHC.TypeNats.KnownNat n4,
     GHC.TypeNats.KnownNat n5, GHC.TypeNats.KnownNat n6,
     GHC.TypeNats.KnownNat n7, GHC.TypeNats.KnownNat n8) =>
    Tensor.Rank
    -> (Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 10,
     Strictness: <L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S(S(S)LLLLLLL),1*U(1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U))><L,C(U)>m,
     Unfolding: (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   ($dKnownNat :: GHC.TypeNats.KnownNat n1)
                   ($dKnownNat1 :: GHC.TypeNats.KnownNat n2)
                   ($dKnownNat2 :: GHC.TypeNats.KnownNat n3)
                   ($dKnownNat3 :: GHC.TypeNats.KnownNat n4)
                   ($dKnownNat4 :: GHC.TypeNats.KnownNat n5)
                   ($dKnownNat5 :: GHC.TypeNats.KnownNat n6)
                   ($dKnownNat6 :: GHC.TypeNats.KnownNat n7)
                   ($dKnownNat7 :: GHC.TypeNats.KnownNat n8)
                   (rank :: Tensor.Rank)
                   (f :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a) ->
                 let {
                   indList :: [Index.Index n1 n2 n3 n4 n5 n6 n7 n8]
                   = Tensor.tensorIndList
                       @ n1
                       @ n2
                       @ n3
                       @ n4
                       @ n5
                       @ n6
                       @ n7
                       @ n8
                       $dKnownNat
                       $dKnownNat1
                       $dKnownNat2
                       $dKnownNat3
                       $dKnownNat4
                       $dKnownNat5
                       $dKnownNat6
                       $dKnownNat7
                       rank
                 } in
                 case Data.Map.Strict.Internal.fromList
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (GHC.List.zip
                           @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                           @ a
                           indList
                           (GHC.Base.map
                              @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                              @ a
                              f
                              indList)) of dt { DEFAULT ->
                 Tensor.Tensor @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8 @ a dt }) -}
2031345f9cf29f6c042e86b8350a2fc6
  mkTensorfromList ::
    [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (l :: [(Index.Index n1 n2 n3 n4 n5 n6 n7 n8, a)]) ->
                 case Data.Map.Strict.Internal.fromList
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        l of dt { DEFAULT ->
                 Tensor.Tensor @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8 @ a dt }) -}
6efb24ddccf9665dbd699e91dd6d233d
  symTensor ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A,C(C(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U)><L,U(U(U),U(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Real.Fractional a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w3 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wsymTensor
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
d99ca0e639c925dc556efc00daeae60d
  tensorAdd ::
    GHC.Num.Num a =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A,A,A,A,A,A)><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 case w2 of ww2 { Tensor.Tensor ww3 ->
                 case Data.Map.Strict.Internal.unionWith
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        @ a
                        (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                        (GHC.Num.+ @ a w)
                        ww1
                        ww3 of dt { DEFAULT ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   dt } } }) -}
8e1f794854d89bc2c6d3671575591521
  tensorContractWith_1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
ec8a6a00f9bfa6c485a3d8b5aa8c213c
  tensorContractWith_19 ::
    (GHC.TypeNats.KnownNat n3, GHC.TypeNats.KnownNat n4) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Tensor.Tensor
         n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n3)
                   (w1 :: GHC.TypeNats.KnownNat n4)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (w4 :: Tensor.Tensor
                            n1 n2 (n3 GHC.TypeNats.+ 1) (n4 GHC.TypeNats.+ 1) n5 n6 n7 n8 a) ->
                 case w4 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wtensorContractWith_19
                        @ n3
                        @ n4
                        @ a
                        @ n1
                        @ n2
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        w3
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
f5b2dabd16345e8ee998f4d55afc7785
  tensorContractWith_2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
75e177f0052fa4c7f69a2260778740ed
  tensorContractWith_20 ::
    (GHC.TypeNats.KnownNat n1, GHC.TypeNats.KnownNat n2) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ a
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n1)
                   (w1 :: GHC.TypeNats.KnownNat n2)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (w4 :: Tensor.Tensor
                            (n1 GHC.TypeNats.+ 1) (n2 GHC.TypeNats.+ 1) n3 n4 n5 n6 n7 n8 a) ->
                 case w4 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wtensorContractWith_20
                        @ n1
                        @ n2
                        @ a
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        w3
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
f04596f955f3e30f9459e535b650bdae
  tensorContractWith_3 ::
    (GHC.TypeNats.KnownNat n7, GHC.TypeNats.KnownNat n8) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Tensor.Tensor
         n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1) a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n7)
                   (w1 :: GHC.TypeNats.KnownNat n8)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (w4 :: Tensor.Tensor
                            n1 n2 n3 n4 n5 n6 (n7 GHC.TypeNats.+ 1) (n8 GHC.TypeNats.+ 1) a) ->
                 case w4 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wtensorContractWith_3
                        @ n7
                        @ n8
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        w
                        w1
                        w2
                        w3
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
fd53639966fdb5f8804d2e0bc1f03852
  tensorContractWith_4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
2b36f7f16c0f3479abe15dbe357bc93b
  tensorContractWith_5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
4f4fab0a8d1968bd989f7015cbf3b61b
  tensorContractWith_9 ::
    (GHC.TypeNats.KnownNat n5, GHC.TypeNats.KnownNat n6) =>
    (GHC.Types.Int, GHC.Types.Int)
    -> (a -> a -> a)
    -> Tensor.Tensor
         n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 5,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,C(C1(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.TypeNats.KnownNat n5)
                   (w1 :: GHC.TypeNats.KnownNat n6)
                   (w2 :: (GHC.Types.Int, GHC.Types.Int))
                   (w3 :: a -> a -> a)
                   (w4 :: Tensor.Tensor
                            n1 n2 n3 n4 (n5 GHC.TypeNats.+ 1) (n6 GHC.TypeNats.+ 1) n7 n8 a) ->
                 case w4 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wtensorContractWith_9
                        @ n5
                        @ n6
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n7
                        @ n8
                        w
                        w1
                        w2
                        w3
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
247591d187fff21da43e3190fd4b1196
  tensorIndList ::
    (GHC.TypeNats.KnownNat n1, GHC.TypeNats.KnownNat n2,
     GHC.TypeNats.KnownNat n3, GHC.TypeNats.KnownNat n4,
     GHC.TypeNats.KnownNat n5, GHC.TypeNats.KnownNat n6,
     GHC.TypeNats.KnownNat n7, GHC.TypeNats.KnownNat n8) =>
    Tensor.Rank -> [Index.Index n1 n2 n3 n4 n5 n6 n7 n8]
  {- Arity: 9,
     Strictness: <L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S(S(S)LLLLLLL),1*U(1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U))> -}
70fa8a4a86ce5c353cbf7f8d846f61aa
  tensorProductNew ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8)
         a
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w3 :: Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a) ->
                 case w2 of ww { Tensor.Tensor ww1 ->
                 case w3 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorProductNew
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ m1
                        @ m2
                        @ m3
                        @ m4
                        @ m5
                        @ m6
                        @ m7
                        @ m8
                        w
                        w1
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ (n1 GHC.TypeNats.+ m1)
                   @ (n2 GHC.TypeNats.+ m2)
                   @ (n3 GHC.TypeNats.+ m3)
                   @ (n4 GHC.TypeNats.+ m4)
                   @ (n5 GHC.TypeNats.+ m5)
                   @ (n6 GHC.TypeNats.+ m6)
                   @ (n7 GHC.TypeNats.+ m7)
                   @ (n8 GHC.TypeNats.+ m8)
                   @ a
                   ww5 } } }) -}
419d42041587ab991a229bb228dec18f
  tensorProductNumeric ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8)
         a
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w3 :: Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a) ->
                 case w2 of ww { Tensor.Tensor ww1 ->
                 case w3 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorProductNumeric
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ m1
                        @ m2
                        @ m3
                        @ m4
                        @ m5
                        @ m6
                        @ m7
                        @ m8
                        w
                        w1
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ (n1 GHC.TypeNats.+ m1)
                   @ (n2 GHC.TypeNats.+ m2)
                   @ (n3 GHC.TypeNats.+ m3)
                   @ (n4 GHC.TypeNats.+ m4)
                   @ (n5 GHC.TypeNats.+ m5)
                   @ (n6 GHC.TypeNats.+ m6)
                   @ (n7 GHC.TypeNats.+ m7)
                   @ (n8 GHC.TypeNats.+ m8)
                   @ a
                   ww5 } } }) -}
6c70acb4fe4970ca38886beeb6c30cbd
  tensorProductNumeric1 ::
    Index.Index
      (n1 GHC.TypeNats.+ m1)
      (n2 GHC.TypeNats.+ m2)
      (n3 GHC.TypeNats.+ m3)
      (n4 GHC.TypeNats.+ m4)
      (n5 GHC.TypeNats.+ m5)
      (n6 GHC.TypeNats.+ m6)
      (n7 GHC.TypeNats.+ m7)
      (n8 GHC.TypeNats.+ m8)
    -> c -> c -> c
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ n1 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   @ c
                   (ds :: Index.Index
                            (n1 GHC.TypeNats.+ m1)
                            (n2 GHC.TypeNats.+ m2)
                            (n3 GHC.TypeNats.+ m3)
                            (n4 GHC.TypeNats.+ m4)
                            (n5 GHC.TypeNats.+ m5)
                            (n6 GHC.TypeNats.+ m6)
                            (n7 GHC.TypeNats.+ m7)
                            (n8 GHC.TypeNats.+ m8))
                   (x :: c)[OneShot]
                   (ds1 :: c)[OneShot] ->
                 x) -}
99a2f2f2e3e441e3f9532bac22d711f7
  tensorProductNumeric2 ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8)
         a
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w3 :: Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 a) ->
                 case w2 of ww { Tensor.Tensor ww1 ->
                 case w3 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorProductNumeric2
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ m1
                        @ m2
                        @ m3
                        @ m4
                        @ m5
                        @ m6
                        @ m7
                        @ m8
                        w
                        w1
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ (n1 GHC.TypeNats.+ m1)
                   @ (n2 GHC.TypeNats.+ m2)
                   @ (n3 GHC.TypeNats.+ m3)
                   @ (n4 GHC.TypeNats.+ m4)
                   @ (n5 GHC.TypeNats.+ m5)
                   @ (n6 GHC.TypeNats.+ m6)
                   @ (n7 GHC.TypeNats.+ m7)
                   @ (n8 GHC.TypeNats.+ m8)
                   @ a
                   ww5 } } }) -}
05216200a08bb52e8b8e53703bbee9c1
  tensorProductWith ::
    (a -> b -> c)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 b
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8)
         c
  {- Arity: 3, Strictness: <L,C(C1(U))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: a -> b -> c)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w2 :: Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 b) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 case w2 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorProductWith
                        @ a
                        @ b
                        @ c
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ m1
                        @ m2
                        @ m3
                        @ m4
                        @ m5
                        @ m6
                        @ m7
                        @ m8
                        w
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ (n1 GHC.TypeNats.+ m1)
                   @ (n2 GHC.TypeNats.+ m2)
                   @ (n3 GHC.TypeNats.+ m3)
                   @ (n4 GHC.TypeNats.+ m4)
                   @ (n5 GHC.TypeNats.+ m5)
                   @ (n6 GHC.TypeNats.+ m6)
                   @ (n7 GHC.TypeNats.+ m7)
                   @ (n8 GHC.TypeNats.+ m8)
                   @ c
                   ww5 } } }) -}
c2d482964799fda1774e8f2b6dbfc114
  tensorProductWith1 ::
    Data.Map.Internal.Map
      (Index.Index
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8))
      c
    -> [Data.Map.Internal.Map
          (Index.Index
             (n1 GHC.TypeNats.+ m1)
             (n2 GHC.TypeNats.+ m2)
             (n3 GHC.TypeNats.+ m3)
             (n4 GHC.TypeNats.+ m4)
             (n5 GHC.TypeNats.+ m5)
             (n6 GHC.TypeNats.+ m6)
             (n7 GHC.TypeNats.+ m7)
             (n8 GHC.TypeNats.+ m8))
          c]
    -> Data.Map.Internal.Map
         (Index.Index
            (n1 GHC.TypeNats.+ m1)
            (n2 GHC.TypeNats.+ m2)
            (n3 GHC.TypeNats.+ m3)
            (n4 GHC.TypeNats.+ m4)
            (n5 GHC.TypeNats.+ m5)
            (n6 GHC.TypeNats.+ m6)
            (n7 GHC.TypeNats.+ m7)
            (n8 GHC.TypeNats.+ m8))
         c
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
11d5869ecaa561807627970652eac817
  tensorProductWith2 ::
    (a -> b -> c)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 b
    -> Tensor.Tensor
         (n1 GHC.TypeNats.+ m1)
         (n2 GHC.TypeNats.+ m2)
         (n3 GHC.TypeNats.+ m3)
         (n4 GHC.TypeNats.+ m4)
         (n5 GHC.TypeNats.+ m5)
         (n6 GHC.TypeNats.+ m6)
         (n7 GHC.TypeNats.+ m7)
         (n8 GHC.TypeNats.+ m8)
         c
  {- Arity: 3, Strictness: <L,C(C1(U))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ m1 :: GHC.Types.Nat
                   @ m2 :: GHC.Types.Nat
                   @ m3 :: GHC.Types.Nat
                   @ m4 :: GHC.Types.Nat
                   @ m5 :: GHC.Types.Nat
                   @ m6 :: GHC.Types.Nat
                   @ m7 :: GHC.Types.Nat
                   @ m8 :: GHC.Types.Nat
                   (w :: a -> b -> c)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w2 :: Tensor.Tensor m1 m2 m3 m4 m5 m6 m7 m8 b) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 case w2 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorProductWith2
                        @ a
                        @ b
                        @ c
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ m1
                        @ m2
                        @ m3
                        @ m4
                        @ m5
                        @ m6
                        @ m7
                        @ m8
                        w
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ (n1 GHC.TypeNats.+ m1)
                   @ (n2 GHC.TypeNats.+ m2)
                   @ (n3 GHC.TypeNats.+ m3)
                   @ (n4 GHC.TypeNats.+ m4)
                   @ (n5 GHC.TypeNats.+ m5)
                   @ (n6 GHC.TypeNats.+ m6)
                   @ (n7 GHC.TypeNats.+ m7)
                   @ (n8 GHC.TypeNats.+ m8)
                   @ c
                   ww5 } } }) -}
bd006493177c1f5b96d23fe52f4df861
  tensorSMult ::
    GHC.Num.Num a =>
    a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C(U)),A,A,A,A)><L,U>,
     Unfolding: (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   ($dNum :: GHC.Num.Num a)
                   (a1 :: a) ->
                 let {
                   f :: a -> a = GHC.Num.* @ a $dNum a1
                 } in
                 \ (ds :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case ds of wild { Tensor.Tensor tMap ->
                 case Data.Map.Strict.Internal.map
                        @ a
                        @ a
                        @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                        f
                        tMap of dt { DEFAULT ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   dt } }) -}
4712786dc2f094bb059ae94da1bab1e3
  tensorSub ::
    GHC.Num.Num a =>
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),C(U),A,A,C(U))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   (w :: GHC.Num.Num a)
                   (w1 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w1 of ww { Tensor.Tensor ww1 ->
                 case w2 of ww2 { Tensor.Tensor ww3 ->
                 case Tensor.$wtensorSub
                        @ a
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        w
                        ww1
                        ww3 of ww4 { Unit# ww5 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww5 } } }) -}
bf772467c4363e927c1ee5deaa31eb8b
  tensorTranspose ::
    GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int)
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
  {- Arity: 3, Strictness: <L,U(U)><L,U(U(U),U(U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (w :: GHC.Types.Int)
                   (w1 :: (GHC.Types.Int, GHC.Types.Int))
                   (w2 :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a) ->
                 case w2 of ww { Tensor.Tensor ww1 ->
                 case Tensor.$wtensorTranspose
                        @ n1
                        @ n2
                        @ n3
                        @ n4
                        @ n5
                        @ n6
                        @ n7
                        @ n8
                        @ a
                        w
                        w1
                        ww1 of ww2 { Unit# ww3 ->
                 Tensor.Tensor
                   @ n1
                   @ n2
                   @ n3
                   @ n4
                   @ n5
                   @ n6
                   @ n7
                   @ n8
                   @ a
                   ww3 } }) -}
289481b68c1c827cbaa3a436209b3d42
  unsafeGetVal ::
    Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a
    -> Index.Index n1 n2 n3 n4 n5 n6 n7 n8 -> a
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ n1 :: GHC.Types.Nat
                   @ n2 :: GHC.Types.Nat
                   @ n3 :: GHC.Types.Nat
                   @ n4 :: GHC.Types.Nat
                   @ n5 :: GHC.Types.Nat
                   @ n6 :: GHC.Types.Nat
                   @ n7 :: GHC.Types.Nat
                   @ n8 :: GHC.Types.Nat
                   @ a
                   (ds :: Tensor.Tensor n1 n2 n3 n4 n5 n6 n7 n8 a)
                   (ind :: Index.Index n1 n2 n3 n4 n5 n6 n7 n8) ->
                 case ds of wild { Tensor.Tensor map1 ->
                 Data.Map.Internal.find
                   @ (Index.Index n1 n2 n3 n4 n5 n6 n7 n8)
                   @ a
                   (Index.$fOrdIndex @ n1 @ n2 @ n3 @ n4 @ n5 @ n6 @ n7 @ n8)
                   ind
                   map1 }) -}
instance [safe] GHC.Base.Functor [Tensor.Tensor]
  = Tensor.$fFunctorTensor
instance [safe] GHC.Read.Read [Tensor.Tensor] = Tensor.$fReadTensor
instance [safe] GHC.Show.Show [Tensor.Tensor] = Tensor.$fShowTensor
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

